{"functions":[],"parties":[{"name":"Party0","source_ref_index":8},{"name":"Party1","source_ref_index":8},{"name":"Party2","source_ref_index":8},{"name":"Party3","source_ref_index":8},{"name":"Party4","source_ref_index":8},{"name":"Party5","source_ref_index":8},{"name":"Party6","source_ref_index":8},{"name":"Party7","source_ref_index":8},{"name":"Party8","source_ref_index":8},{"name":"Party9","source_ref_index":8}],"inputs":[{"type":"SecretInteger","party":"Party0","name":"num_0","doc":"","source_ref_index":2},{"type":"SecretInteger","party":"Party1","name":"num_1","doc":"","source_ref_index":2},{"type":"SecretInteger","party":"Party2","name":"num_2","doc":"","source_ref_index":2},{"type":"SecretInteger","party":"Party3","name":"num_3","doc":"","source_ref_index":2},{"type":"SecretInteger","party":"Party4","name":"num_4","doc":"","source_ref_index":2},{"type":"SecretInteger","party":"Party5","name":"num_5","doc":"","source_ref_index":2},{"type":"SecretInteger","party":"Party6","name":"num_6","doc":"","source_ref_index":2},{"type":"SecretInteger","party":"Party7","name":"num_7","doc":"","source_ref_index":2},{"type":"SecretInteger","party":"Party8","name":"num_8","doc":"","source_ref_index":2},{"type":"SecretInteger","party":"Party9","name":"num_9","doc":"","source_ref_index":2}],"literals":[{"name":"0420609fa1d35394f41049df03ef341f","value":"0","type":"Integer"},{"name":"10d33944d37d5b1b833be6fd73d3033c","value":"1","type":"Integer"},{"name":"3a980e5ac46f3aa9cc3f1d27d3b9f1f9","value":"100","type":"Integer"},{"name":"84e55ea59b6b9ec4c529ed7e4655425e","value":"99","type":"Integer"}],"outputs":[{"name":"is_present_1","operation_id":4391657520,"party":"Party0","type":"SecretBoolean","source_ref_index":5},{"name":"is_present_2","operation_id":4391704368,"party":"Party0","type":"SecretBoolean","source_ref_index":7}],"operations":{"4391656560":{"LiteralReference":{"id":4391656560,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391516880":{"IfElse":{"id":4391516880,"this":4391516160,"arg_0":4391516448,"arg_1":4391516688,"type":"SecretInteger","source_ref_index":1}},"4391699760":{"IfElse":{"id":4391699760,"this":4391698944,"arg_0":4391699232,"arg_1":4391699520,"type":"SecretInteger","source_ref_index":1}},"4391664336":{"IfElse":{"id":4391664336,"this":4391663520,"arg_0":4391663808,"arg_1":4391664096,"type":"SecretInteger","source_ref_index":1}},"4391513232":{"InputReference":{"id":4391513232,"refers_to":"num_9","type":"SecretInteger","source_ref_index":2}},"4391658048":{"LiteralReference":{"id":4391658048,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":4}},"4391654304":{"Addition":{"id":4391654304,"left":4391653056,"right":4391654016,"type":"SecretInteger","source_ref_index":1}},"4391514960":{"Equals":{"id":4391514960,"left":4391513424,"right":4391511216,"type":"SecretBoolean","source_ref_index":1}},"4391660448":{"IfElse":{"id":4391660448,"this":4391659632,"arg_0":4391659920,"arg_1":4391660208,"type":"SecretInteger","source_ref_index":1}},"4391704368":{"LessThan":{"id":4391704368,"left":4391704128,"right":4391703888,"type":"SecretBoolean","source_ref_index":0}},"4391517360":{"Equals":{"id":4391517360,"left":4391513424,"right":4391511792,"type":"SecretBoolean","source_ref_index":1}},"4391665392":{"LiteralReference":{"id":4391665392,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391513760":{"LiteralReference":{"id":4391513760,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":4}},"4391701296":{"Addition":{"id":4391701296,"left":4391700000,"right":4391701056,"type":"SecretInteger","source_ref_index":1}},"4391662224":{"Equals":{"id":4391662224,"left":4391657760,"right":4391511792,"type":"SecretBoolean","source_ref_index":1}},"4391659920":{"LiteralReference":{"id":4391659920,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391703888":{"Addition":{"id":4391703888,"left":4391702592,"right":4391703648,"type":"SecretInteger","source_ref_index":1}},"4391664816":{"Equals":{"id":4391664816,"left":4391657760,"right":4391512272,"type":"SecretBoolean","source_ref_index":1}},"4391665104":{"LiteralReference":{"id":4391665104,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391657760":{"LiteralReference":{"id":4391657760,"refers_to":"84e55ea59b6b9ec4c529ed7e4655425e","type":"Integer","source_ref_index":6}},"4391698944":{"Equals":{"id":4391698944,"left":4391657760,"right":4391512512,"type":"SecretBoolean","source_ref_index":1}},"4391651856":{"Addition":{"id":4391651856,"left":4391650656,"right":4391651616,"type":"SecretInteger","source_ref_index":1}},"4391652816":{"IfElse":{"id":4391652816,"this":4391652096,"arg_0":4391652384,"arg_1":4391652624,"type":"SecretInteger","source_ref_index":1}},"4391514240":{"LiteralReference":{"id":4391514240,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391702352":{"IfElse":{"id":4391702352,"this":4391701536,"arg_0":4391701824,"arg_1":4391702112,"type":"SecretInteger","source_ref_index":1}},"4391651616":{"IfElse":{"id":4391651616,"this":4391650896,"arg_0":4391651184,"arg_1":4391651424,"type":"SecretInteger","source_ref_index":1}},"4391511216":{"InputReference":{"id":4391511216,"refers_to":"num_1","type":"SecretInteger","source_ref_index":2}},"4391701056":{"IfElse":{"id":4391701056,"this":4391700240,"arg_0":4391700528,"arg_1":4391700816,"type":"SecretInteger","source_ref_index":1}},"4391517888":{"LiteralReference":{"id":4391517888,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391703648":{"IfElse":{"id":4391703648,"this":4391702832,"arg_0":4391703120,"arg_1":4391703408,"type":"SecretInteger","source_ref_index":1}},"4391654928":{"LiteralReference":{"id":4391654928,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391511792":{"InputReference":{"id":4391511792,"refers_to":"num_3","type":"SecretInteger","source_ref_index":2}},"4391655984":{"Equals":{"id":4391655984,"left":4391513424,"right":4391513232,"type":"SecretBoolean","source_ref_index":1}},"4391515248":{"LiteralReference":{"id":4391515248,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391516448":{"LiteralReference":{"id":4391516448,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391658624":{"LiteralReference":{"id":4391658624,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391650416":{"IfElse":{"id":4391650416,"this":4391649696,"arg_0":4391649984,"arg_1":4391650224,"type":"SecretInteger","source_ref_index":1}},"4391515920":{"Addition":{"id":4391515920,"left":4391514768,"right":4391515680,"type":"SecretInteger","source_ref_index":1}},"4391663808":{"LiteralReference":{"id":4391663808,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391702112":{"LiteralReference":{"id":4391702112,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391663040":{"IfElse":{"id":4391663040,"this":4391662224,"arg_0":4391662512,"arg_1":4391662800,"type":"SecretInteger","source_ref_index":1}},"4391699232":{"LiteralReference":{"id":4391699232,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391658336":{"Equals":{"id":4391658336,"left":4391657760,"right":4350059936,"type":"SecretBoolean","source_ref_index":1}},"4391512272":{"InputReference":{"id":4391512272,"refers_to":"num_5","type":"SecretInteger","source_ref_index":2}},"4391650896":{"Equals":{"id":4391650896,"left":4391513424,"right":4391512272,"type":"SecretBoolean","source_ref_index":1}},"4391649984":{"LiteralReference":{"id":4391649984,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391517648":{"LiteralReference":{"id":4391517648,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391702592":{"Addition":{"id":4391702592,"left":4391701296,"right":4391702352,"type":"SecretInteger","source_ref_index":1}},"4391701824":{"LiteralReference":{"id":4391701824,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391698704":{"Addition":{"id":4391698704,"left":4391664576,"right":4391698512,"type":"SecretInteger","source_ref_index":1}},"4391700816":{"LiteralReference":{"id":4391700816,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391703408":{"LiteralReference":{"id":4391703408,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391664096":{"LiteralReference":{"id":4391664096,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391663280":{"Addition":{"id":4391663280,"left":4391661984,"right":4391663040,"type":"SecretInteger","source_ref_index":1}},"4391650224":{"LiteralReference":{"id":4391650224,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391700240":{"Equals":{"id":4391700240,"left":4391657760,"right":4391512752,"type":"SecretBoolean","source_ref_index":1}},"4391701536":{"Equals":{"id":4391701536,"left":4391657760,"right":4391512992,"type":"SecretBoolean","source_ref_index":1}},"4391514480":{"LiteralReference":{"id":4391514480,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391649696":{"Equals":{"id":4391649696,"left":4391513424,"right":4391512032,"type":"SecretBoolean","source_ref_index":1}},"4391653824":{"LiteralReference":{"id":4391653824,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391654592":{"Equals":{"id":4391654592,"left":4391513424,"right":4391512992,"type":"SecretBoolean","source_ref_index":1}},"4391659632":{"Equals":{"id":4391659632,"left":4391657760,"right":4391511216,"type":"SecretBoolean","source_ref_index":1}},"4350059936":{"InputReference":{"id":4350059936,"refers_to":"num_0","type":"SecretInteger","source_ref_index":2}},"4391515680":{"IfElse":{"id":4391515680,"this":4391514960,"arg_0":4391515248,"arg_1":4391515488,"type":"SecretInteger","source_ref_index":1}},"4391661984":{"Addition":{"id":4391661984,"left":4391660688,"right":4391661744,"type":"SecretInteger","source_ref_index":1}},"4391657280":{"LiteralReference":{"id":4391657280,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":0}},"4391659152":{"IfElse":{"id":4391659152,"this":4391658336,"arg_0":4391658624,"arg_1":4391658912,"type":"SecretInteger","source_ref_index":1}},"4391658912":{"LiteralReference":{"id":4391658912,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391652096":{"Equals":{"id":4391652096,"left":4391513424,"right":4391512512,"type":"SecretBoolean","source_ref_index":1}},"4391511552":{"InputReference":{"id":4391511552,"refers_to":"num_2","type":"SecretInteger","source_ref_index":2}},"4391700000":{"Addition":{"id":4391700000,"left":4391698704,"right":4391699760,"type":"SecretInteger","source_ref_index":1}},"4391661744":{"IfElse":{"id":4391661744,"this":4391660928,"arg_0":4391661216,"arg_1":4391661504,"type":"SecretInteger","source_ref_index":1}},"4391653296":{"Equals":{"id":4391653296,"left":4391513424,"right":4391512752,"type":"SecretBoolean","source_ref_index":1}},"4391703120":{"LiteralReference":{"id":4391703120,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391661504":{"LiteralReference":{"id":4391661504,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391515488":{"LiteralReference":{"id":4391515488,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391654016":{"IfElse":{"id":4391654016,"this":4391653296,"arg_0":4391653584,"arg_1":4391653824,"type":"SecretInteger","source_ref_index":1}},"4391650656":{"Addition":{"id":4391650656,"left":4391649456,"right":4391650416,"type":"SecretInteger","source_ref_index":1}},"4391661216":{"LiteralReference":{"id":4391661216,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391512512":{"InputReference":{"id":4391512512,"refers_to":"num_6","type":"SecretInteger","source_ref_index":2}},"4391657040":{"Addition":{"id":4391657040,"left":4391655744,"right":4391656800,"type":"SecretInteger","source_ref_index":1}},"4391655504":{"IfElse":{"id":4391655504,"this":4391654592,"arg_0":4391654928,"arg_1":4391655264,"type":"SecretInteger","source_ref_index":1}},"4391657520":{"LessThan":{"id":4391657520,"left":4391657280,"right":4391657040,"type":"SecretBoolean","source_ref_index":0}},"4391653584":{"LiteralReference":{"id":4391653584,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391514768":{"Addition":{"id":4391514768,"left":4391513760,"right":4391514672,"type":"SecretInteger","source_ref_index":1}},"4391514672":{"IfElse":{"id":4391514672,"this":4391513904,"arg_0":4391514240,"arg_1":4391514480,"type":"SecretInteger","source_ref_index":1}},"4391660928":{"Equals":{"id":4391660928,"left":4391657760,"right":4391511552,"type":"SecretBoolean","source_ref_index":1}},"4391516160":{"Equals":{"id":4391516160,"left":4391513424,"right":4391511552,"type":"SecretBoolean","source_ref_index":1}},"4391512992":{"InputReference":{"id":4391512992,"refers_to":"num_8","type":"SecretInteger","source_ref_index":2}},"4391653056":{"Addition":{"id":4391653056,"left":4391651856,"right":4391652816,"type":"SecretInteger","source_ref_index":1}},"4391518080":{"IfElse":{"id":4391518080,"this":4391517360,"arg_0":4391517648,"arg_1":4391517888,"type":"SecretInteger","source_ref_index":1}},"4391516688":{"LiteralReference":{"id":4391516688,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391664576":{"Addition":{"id":4391664576,"left":4391663280,"right":4391664336,"type":"SecretInteger","source_ref_index":1}},"4391698512":{"IfElse":{"id":4391698512,"this":4391664816,"arg_0":4391665104,"arg_1":4391665392,"type":"SecretInteger","source_ref_index":1}},"4391649456":{"Addition":{"id":4391649456,"left":4391517120,"right":4391518080,"type":"SecretInteger","source_ref_index":1}},"4391651184":{"LiteralReference":{"id":4391651184,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391699520":{"LiteralReference":{"id":4391699520,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391512752":{"InputReference":{"id":4391512752,"refers_to":"num_7","type":"SecretInteger","source_ref_index":2}},"4391700528":{"LiteralReference":{"id":4391700528,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391660208":{"LiteralReference":{"id":4391660208,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391656800":{"IfElse":{"id":4391656800,"this":4391655984,"arg_0":4391656272,"arg_1":4391656560,"type":"SecretInteger","source_ref_index":1}},"4391660688":{"Addition":{"id":4391660688,"left":4391659392,"right":4391660448,"type":"SecretInteger","source_ref_index":1}},"4391652384":{"LiteralReference":{"id":4391652384,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391659392":{"Addition":{"id":4391659392,"left":4391658048,"right":4391659152,"type":"SecretInteger","source_ref_index":1}},"4391704128":{"LiteralReference":{"id":4391704128,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":0}},"4391702832":{"Equals":{"id":4391702832,"left":4391657760,"right":4391513232,"type":"SecretBoolean","source_ref_index":1}},"4391656272":{"LiteralReference":{"id":4391656272,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391513424":{"LiteralReference":{"id":4391513424,"refers_to":"3a980e5ac46f3aa9cc3f1d27d3b9f1f9","type":"Integer","source_ref_index":3}},"4391663520":{"Equals":{"id":4391663520,"left":4391657760,"right":4391512032,"type":"SecretBoolean","source_ref_index":1}},"4391517120":{"Addition":{"id":4391517120,"left":4391515920,"right":4391516880,"type":"SecretInteger","source_ref_index":1}},"4391513904":{"Equals":{"id":4391513904,"left":4391513424,"right":4350059936,"type":"SecretBoolean","source_ref_index":1}},"4391662512":{"LiteralReference":{"id":4391662512,"refers_to":"10d33944d37d5b1b833be6fd73d3033c","type":"Integer","source_ref_index":1}},"4391512032":{"InputReference":{"id":4391512032,"refers_to":"num_4","type":"SecretInteger","source_ref_index":2}},"4391655264":{"LiteralReference":{"id":4391655264,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391652624":{"LiteralReference":{"id":4391652624,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391655744":{"Addition":{"id":4391655744,"left":4391654304,"right":4391655504,"type":"SecretInteger","source_ref_index":1}},"4391651424":{"LiteralReference":{"id":4391651424,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}},"4391662800":{"LiteralReference":{"id":4391662800,"refers_to":"0420609fa1d35394f41049df03ef341f","type":"Integer","source_ref_index":1}}},"source_files":{"funcs.py":"\"\"\"\nThis module provides common functions to work with Nada Numpy. It includes: \n- the creation and manipulation of arrays and party objects.\n- non-linear functions over arrays.\n- random operations over arrays: random generation, shuffling.\n\"\"\"\n\n# pylint:disable=too-many-lines\n\nfrom typing import Any, Callable, List, Optional, Sequence, Tuple, Union\n\nimport numpy as np\nfrom nada_dsl import (Boolean, Integer, Output, Party, PublicInteger,\n                      PublicUnsignedInteger, SecretInteger,\n                      SecretUnsignedInteger, UnsignedInteger)\n\nfrom nada_numpy.array import NadaArray\nfrom nada_numpy.nada_typing import AnyNadaType, NadaCleartextNumber\nfrom nada_numpy.types import Rational, SecretRational, rational\nfrom nada_numpy.utils import copy_metadata\n\n__all__ = [\n    \"parties\",\n    \"from_list\",\n    \"ones\",\n    \"ones_like\",\n    \"zeros\",\n    \"zeros_like\",\n    \"alphas\",\n    \"alphas_like\",\n    \"array\",\n    \"random\",\n    \"output\",\n    \"vstack\",\n    \"hstack\",\n    \"ndim\",\n    \"shape\",\n    \"size\",\n    \"pad\",\n    \"frompyfunc\",\n    \"vectorize\",\n    \"eye\",\n    \"arange\",\n    \"linspace\",\n    \"split\",\n    \"compress\",\n    \"copy\",\n    \"cumprod\",\n    \"cumsum\",\n    \"diagonal\",\n    \"mean\",\n    \"prod\",\n    \"put\",\n    \"ravel\",\n    \"repeat\",\n    \"reshape\",\n    \"resize\",\n    \"squeeze\",\n    \"sum\",\n    \"swapaxes\",\n    \"take\",\n    \"trace\",\n    \"transpose\",\n    \"sign\",\n    \"abs\",\n    \"exp\",\n    \"polynomial\",\n    \"log\",\n    \"reciprocal\",\n    \"inv_sqrt\",\n    \"sqrt\",\n    \"cossin\",\n    \"sin\",\n    \"cos\",\n    \"tan\",\n    \"tanh\",\n    \"sigmoid\",\n    \"gelu\",\n    \"silu\",\n    \"shuffle\",\n]\n\n\ndef parties(num: int, party_names: Optional[List[str]] = None) -> List[Party]:\n    \"\"\"\n    Create a list of Party objects with specified names.\n\n    Args:\n        num (int): The number of parties to create.\n        party_names (List[str], optional): Party names to use. Defaults to None.\n\n    Raises:\n        ValueError: Raised when incorrect number of party names is supplied.\n\n    Returns:\n        List[Party]: A list of Party objects.\n    \"\"\"\n    if party_names is None:\n        party_names = [f\"Party{i}\" for i in range(num)]\n\n    if len(party_names) != num:\n        num_supplied_parties = len(party_names)\n        raise ValueError(\n            f\"Incorrect number of party names. Expected {num}, received {num_supplied_parties}\"\n        )\n\n    return [Party(name=party_name) for party_name in party_names]\n\n\ndef __from_numpy(arr: np.ndarray, nada_type: NadaCleartextNumber) -> List:\n    \"\"\"\n    Recursively convert a n-dimensional NumPy array to a nested list of NadaInteger objects.\n\n    Args:\n        arr (np.ndarray): A NumPy array of integers.\n        nada_type (type): The type of NadaInteger objects to create.\n\n    Returns:\n        List: A nested list of NadaInteger objects.\n    \"\"\"\n    if len(arr.shape) == 1:\n        if isinstance(nada_type, Rational):\n            return [nada_type(elem) for elem in arr]  # type: ignore\n        return [nada_type(int(elem)) for elem in arr]  # type: ignore\n    return [__from_numpy(arr[i], nada_type) for i in range(arr.shape[0])]\n\n\ndef from_list(\n    lst: Union[List, np.ndarray], nada_type: NadaCleartextNumber = Integer\n) -> NadaArray:\n    \"\"\"\n    Create a cleartext NadaArray from a list of integers.\n\n    Args:\n        lst (Union[List, np.ndarray]): A list of integers representing the elements of the array.\n        nada_type (type, optional): The type of NadaInteger objects to create. Defaults to Integer.\n\n    Returns:\n        NadaArray: The created NadaArray.\n    \"\"\"\n    if nada_type == Rational:\n        nada_type = rational\n    lst_np = np.array(lst)\n    return NadaArray(np.array(__from_numpy(lst_np, nada_type)))\n\n\ndef ones(dims: Sequence[int], nada_type: NadaCleartextNumber = Integer) -> NadaArray:\n    \"\"\"\n    Create a cleartext NadaArray filled with ones.\n\n    Args:\n        dims (Sequence[int]): A list of integers representing the dimensions of the array.\n        nada_type (type, optional): The type of NadaInteger objects to create. Defaults to Integer.\n\n    Returns:\n        NadaArray: The created NadaArray filled with ones.\n    \"\"\"\n    if nada_type == Rational:\n        nada_type = rational\n    return from_list(np.ones(dims), nada_type)\n\n\ndef ones_like(\n    a: np.ndarray | NadaArray, nada_type: NadaCleartextNumber = Integer\n) -> NadaArray:\n    \"\"\"\n    Create a cleartext NadaArray filled with one with the same shape and type as a given array.\n\n    Args:\n        a (np.ndarray | NadaArray): A reference array.\n        nada_type (type, optional): The type of NadaInteger objects to create. Defaults to Integer.\n\n    Returns:\n        NadaArray: The created NadaArray filled with ones.\n    \"\"\"\n    if nada_type == Rational:\n        nada_type = rational\n    if isinstance(a, NadaArray):\n        a = a.inner\n    return from_list(np.ones_like(a), nada_type)\n\n\ndef zeros(dims: Sequence[int], nada_type: NadaCleartextNumber = Integer) -> NadaArray:\n    \"\"\"\n    Create a cleartext NadaArray filled with zeros.\n\n    Args:\n        dims (Sequence[int]): A list of integers representing the dimensions of the array.\n        nada_type (type, optional): The type of NadaInteger objects to create. Defaults to Integer.\n\n    Returns:\n        NadaArray: The created NadaArray filled with zeros.\n    \"\"\"\n    if nada_type == Rational:\n        nada_type = rational\n    return from_list(np.zeros(dims), nada_type)\n\n\ndef zeros_like(\n    a: np.ndarray | NadaArray, nada_type: NadaCleartextNumber = Integer\n) -> NadaArray:\n    \"\"\"\n    Create a cleartext NadaArray filled with zeros with the same shape and type as a given array.\n\n    Args:\n        a (np.ndarray | NadaArray): A reference array.\n        nada_type (type, optional): The type of NadaInteger objects to create. Defaults to Integer.\n\n    Returns:\n        NadaArray: The created NadaArray filled with zeros.\n    \"\"\"\n    if nada_type == Rational:\n        nada_type = rational\n    if isinstance(a, NadaArray):\n        a = a.inner\n    return from_list(np.zeros_like(a), nada_type)\n\n\ndef alphas(dims: Sequence[int], alpha: Any) -> NadaArray:\n    \"\"\"\n    Create a NadaArray filled with a certain constant value.\n\n    Args:\n        dims (Sequence[int]): A list of integers representing the dimensions of the array.\n        alpha (Any): Some constant value.\n\n    Returns:\n        NadaArray: NadaArray filled with constant value.\n    \"\"\"\n    ones_array = np.ones(dims)\n    return NadaArray(np.frompyfunc(lambda _: alpha, 1, 1)(ones_array))\n\n\ndef alphas_like(a: np.ndarray | NadaArray, alpha: Any) -> NadaArray:\n    \"\"\"\n    Create a NadaArray filled with a certain constant value\n    with the same shape and type as a given array.\n\n    Args:\n        a (np.ndarray | NadaArray): Reference array.\n        alpha (Any): Some constant value.\n\n    Returns:\n        NadaArray: NadaArray filled with constant value.\n    \"\"\"\n    if isinstance(a, NadaArray):\n        a = a.inner\n    ones_array = np.ones_like(a)\n    return NadaArray(np.frompyfunc(lambda _: alpha, 1, 1)(ones_array))\n\n\ndef array(\n    dims: Sequence[int],\n    party: Party,\n    prefix: str,\n    nada_type: Union[\n        SecretInteger,\n        SecretUnsignedInteger,\n        PublicInteger,\n        PublicUnsignedInteger,\n        SecretRational,\n        Rational,\n    ],\n) -> NadaArray:\n    \"\"\"\n    Create a NadaArray with the specified dimensions and elements of the given type.\n\n    Args:\n        dims (Sequence[int]): A list of integers representing the dimensions of the array.\n        party (Party): The party object.\n        prefix (str): A prefix for naming the array elements.\n        nada_type (type): The type of elements to create.\n\n    Returns:\n        NadaArray: The created NadaArray.\n    \"\"\"\n    return NadaArray.array(dims, party, prefix, nada_type)\n\n\ndef random(\n    dims: Sequence[int],\n    nada_type: SecretInteger | SecretUnsignedInteger | SecretRational = SecretInteger,\n) -> NadaArray:\n    \"\"\"\n    Create a random NadaArray with the specified dimensions.\n\n    Args:\n        dims (Sequence[int]): A list of integers representing the dimensions of the array.\n        nada_type (type, optional): The type of elements to create. Defaults to SecretInteger.\n\n    Returns:\n        NadaArray: A NadaArray with random values of the specified type.\n    \"\"\"\n    return NadaArray.random(dims, nada_type)\n\n\ndef output(\n    value: Union[NadaArray, AnyNadaType], party: Party, prefix: str\n) -> List[Output]:\n    \"\"\"\n    Generate a list of Output objects for some provided value.\n\n    Args:\n        value (Union[NadaArray, AnyNadaType]): The input NadaArray.\n        party (Party): The party object.\n        prefix (str): The prefix for naming the Output objects.\n\n    Returns:\n        List[Output]: A list of Output objects.\n    \"\"\"\n    if isinstance(value, NadaArray):\n        # pylint:disable=protected-access\n        return NadaArray._output_array(value, party, prefix)\n    if isinstance(value, (Rational, SecretRational)):\n        value = value.value\n    return [Output(value, prefix, party)]\n\n\ndef vstack(arr_list: list) -> NadaArray:\n    \"\"\"\n    Stack arrays in sequence vertically (row wise).\n\n    Args:\n        arr_list (list): A list of NadaArray objects to stack.\n\n    Returns:\n        NadaArray: The stacked NadaArray.\n    \"\"\"\n    return NadaArray(np.vstack(arr_list))\n\n\ndef hstack(arr_list: list) -> NadaArray:\n    \"\"\"\n    Stack arrays in sequence horizontally (column wise).\n\n    Args:\n        arr_list (list): A list of NadaArray objects to stack.\n\n    Returns:\n        NadaArray: The stacked NadaArray.\n    \"\"\"\n    return NadaArray(np.hstack(arr_list))\n\n\ndef ndim(arr: NadaArray) -> int:\n    \"\"\"\n    Returns number of array dimensions.\n\n    Args:\n        arr (NadaArray): Input array.\n\n    Returns:\n        bool: Array dimensions.\n    \"\"\"\n    return arr.ndim\n\n\ndef shape(arr: NadaArray) -> Tuple[int]:\n    \"\"\"\n    Returns Array shape.\n\n    Args:\n        arr (NadaArray): Input array.\n\n    Returns:\n        bool: Array shape.\n    \"\"\"\n    return arr.shape\n\n\ndef size(arr: NadaArray) -> int:\n    \"\"\"\n    Returns array size.\n\n    Args:\n        arr (NadaArray): Input array.\n\n    Returns:\n        bool: Array size.\n    \"\"\"\n    return arr.size\n\n\ndef to_nada(arr: np.ndarray, nada_type: NadaCleartextNumber) -> NadaArray:\n    \"\"\"\n    Converts a plain-text NumPy array to the equivalent NadaArray with\n    a specified compatible NadaType.\n\n    Args:\n        arr (np.ndarray): Input Numpy array.\n        nada_type (NadaCleartextNumber): Desired clear-text NadaType.\n\n    Returns:\n        NadaArray: Output NadaArray.\n    \"\"\"\n    if nada_type == Rational:\n        nada_type = rational\n    else:\n        arr = arr.astype(int)\n    return NadaArray(np.frompyfunc(nada_type, 1, 1)(arr))  # type: ignore\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.pad)\ndef pad(\n    arr: NadaArray,\n    pad_width: Union[Sequence[int], int],\n    mode: str = \"constant\",\n    **kwargs,\n) -> NadaArray:\n    if mode not in {\"constant\", \"edge\", \"reflect\", \"symmetric\", \"wrap\"}:\n        raise NotImplementedError(\n            f\"Not currently possible to pad NadaArray in mode `{mode}`\"\n        )\n\n    # Override python defaults by NadaType defaults\n    overriden_kwargs = {}\n    if mode == \"constant\" and \"constant_values\" not in kwargs:\n        if arr.is_rational:\n            default = rational(0)\n        elif arr.is_integer:\n            default = Integer(0)\n        elif arr.is_unsigned_integer:\n            default = UnsignedInteger(0)\n        else:\n            default = Boolean(False)\n\n        overriden_kwargs[\"constant_values\"] = kwargs.get(\"constant_values\", default)\n\n    padded_inner = np.pad(  # type: ignore\n        arr.inner,\n        pad_width,\n        mode,\n        **overriden_kwargs,\n        **kwargs,\n    )\n\n    return NadaArray(padded_inner)\n\n\n# pylint:disable=too-few-public-methods\nclass NadaCallable:\n    \"\"\"Class that wraps a vectorized NumPy function\"\"\"\n\n    def __init__(self, vfunc: Callable) -> None:\n        \"\"\"\n        Initialization.\n\n        Args:\n            vfunc (Callable): Vectorized function to wrap.\n        \"\"\"\n        self.vfunc = vfunc\n\n    def __call__(self, *args, **kwargs) -> Any:\n        \"\"\"\n        Routes function call to wrapped vectorized function while\n        ensuring any resulting NumPy arrays are converted to NadaArrays.\n\n        Returns:\n            Any: Function result.\n        \"\"\"\n        result = self.vfunc(*args, **kwargs)\n        if isinstance(result, np.ndarray):\n            return NadaArray(result)\n        if isinstance(result, Sequence):\n            return type(result)(  # type: ignore\n                NadaArray(value) if isinstance(value, np.ndarray) else value\n                for value in result\n            )\n        return result\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.frompyfunc)\ndef frompyfunc(*args, **kwargs) -> NadaCallable:\n    return NadaCallable(np.frompyfunc(*args, **kwargs))\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.vectorize)\ndef vectorize(*args, **kwargs) -> NadaCallable:\n    return NadaCallable(np.vectorize(*args, **kwargs))\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.eye)\ndef eye(*args, nada_type: NadaCleartextNumber, **kwargs) -> NadaArray:\n    return to_nada(np.eye(*args, **kwargs), nada_type)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.arange)\ndef arange(*args, nada_type: NadaCleartextNumber, **kwargs) -> NadaArray:\n    return to_nada(np.arange(*args, **kwargs), nada_type)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.linspace)\ndef linspace(*args, nada_type: NadaCleartextNumber, **kwargs) -> NadaArray:\n    return to_nada(np.linspace(*args, **kwargs), nada_type)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.split)\ndef split(a: NadaArray, *args, **kwargs) -> List[NadaArray]:\n    return [NadaArray(arr) for arr in np.split(a.inner, *args, **kwargs)]\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.compress)\ndef compress(a: NadaArray, *args, **kwargs):\n    return a.compress(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.copy)\ndef copy(a: NadaArray, *args, **kwargs):\n    return a.copy(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.cumprod)\ndef cumprod(a: NadaArray, *args, **kwargs):\n    return a.cumprod(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.cumsum)\ndef cumsum(a: NadaArray, *args, **kwargs):\n    return a.cumsum(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.diagonal)\ndef diagonal(a: NadaArray, *args, **kwargs):\n    return a.diagonal(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.diagonal)\ndef mean(a: NadaArray, *args, **kwargs):\n    return a.mean(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.prod)\ndef prod(a: NadaArray, *args, **kwargs):\n    return a.prod(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.put)\ndef put(a: NadaArray, *args, **kwargs):\n    return a.put(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.ravel)\ndef ravel(a: NadaArray, *args, **kwargs):\n    return a.ravel(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.repeat)\ndef repeat(a: NadaArray, *args, **kwargs):\n    return a.repeat(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.reshape)\ndef reshape(a: NadaArray, *args, **kwargs):\n    return a.reshape(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.resize)\ndef resize(a: NadaArray, *args, **kwargs):\n    return a.resize(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.squeeze)\ndef squeeze(a: NadaArray, *args, **kwargs):\n    return a.squeeze(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring,redefined-builtin\n@copy_metadata(np.sum)\ndef sum(a: NadaArray, *args, **kwargs):\n    return a.sum(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.swapaxes)\ndef swapaxes(a: NadaArray, *args, **kwargs):\n    return a.swapaxes(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.take)\ndef take(a: NadaArray, *args, **kwargs):\n    return a.take(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.trace)\ndef trace(a: NadaArray, *args, **kwargs):\n    return a.trace(*args, **kwargs)\n\n\n# pylint:disable=missing-function-docstring\n@copy_metadata(np.transpose)\ndef transpose(a: NadaArray, *args, **kwargs):\n    return a.transpose(*args, **kwargs)\n\n\n# Non-linear functions\n\n\ndef sign(arr: NadaArray) -> \"NadaArray\":\n    \"\"\"Computes the sign value (0 is considered positive)\"\"\"\n    return arr.sign()\n\n\ndef abs(arr: NadaArray) -> \"NadaArray\":\n    \"\"\"Computes the absolute value\"\"\"\n    return arr.abs()\n\n\ndef exp(arr: NadaArray, iterations: int = 8) -> \"NadaArray\":\n    \"\"\"\n    Approximates the exponential function using a limit approximation.\n\n    The exponential function is approximated using the following limit:\n\n        exp(x) = lim_{n -> ∞} (1 + x / n) ^ n\n\n    The exponential function is computed by choosing n = 2 ** d, where d is set to `iterations`.\n    The calculation is performed by computing (1 + x / n) once and then squaring it `d` times.\n\n    Approximation accuracy range (with 16 bit precision):\n    + ---------------------------------- +\n    |  Input range x |  Relative error   |\n    + ---------------------------------- +\n    |   [-2, 2]      |       <1%         |\n    |   [-7, 7]      |       <10%        |\n    |   [-8, 15]     |       <35%        |\n    + ---------------------------------- +\n\n    Args:\n        iterations (int, optional): The number of iterations for the limit approximation.\n            Defaults to 8.\n\n    Returns:\n        NadaArray: The approximated value of the exponential function.\n    \"\"\"\n    return arr.exp(iterations=iterations)\n\n\ndef polynomial(arr: NadaArray, coefficients: list) -> \"NadaArray\":\n    \"\"\"\n    Computes a polynomial function on a value with given coefficients.\n\n    The coefficients can be provided as a list of values.\n    They should be ordered from the linear term (order 1) first, ending with the highest order term.\n    **Note: The constant term is not included.**\n\n    Args:\n        coefficients (list): The coefficients of the polynomial, ordered by increasing degree.\n\n    Returns:\n        NadaArray: The result of the polynomial function applied to the input x.\n    \"\"\"\n    return arr.polynomial(coefficients=coefficients)\n\n\ndef log(\n    arr: NadaArray,\n    input_in_01: bool = False,\n    iterations: int = 2,\n    exp_iterations: int = 8,\n    order: int = 8,\n) -> \"NadaArray\":\n    \"\"\"\n    Approximates the natural logarithm using 8th order modified Householder iterations.\n    This approximation is accurate within 2% relative error on the interval [0.0001, 250].\n\n    The iterations are computed as follows:\n\n        h = 1 - x * exp(-y_n)\n        y_{n+1} = y_n - sum(h^k / k for k in range(1, order + 1))\n\n    Approximation accuracy range (with 16 bit precision):\n    + ------------------------------------- +\n    |    Input range x  |  Relative error   |\n    + ------------------------------------- +\n    | [0.001, 200]      |     <1%           |\n    | [0.00003, 253]    |     <10%          |\n    | [0.0000001, 253]  |     <40%          |\n    | [253, +∞[         |     Unstable      |\n    + ------------------------------------- +\n\n    Args:\n        input_in_01 (bool, optional): Indicates if the input is within the domain [0, 1].\n            This setting optimizes the function for this domain, useful for computing\n            log-probabilities in entropy functions.\n\n            To shift the domain of convergence, a constant 'a' is used with the identity:\n\n                ln(u) = ln(au) - ln(a)\n\n            Given the convergence domain for log() function is approximately [1e-4, 1e2],\n            we set a = 100.\n            Defaults to False.\n        iterations (int, optional): Number of Householder iterations for the approximation.\n            Defaults to 2.\n        exp_iterations (int, optional): Number of iterations for the limit approximation of exp.\n            Defaults to 8.\n        order (int, optional): Number of polynomial terms used (order of Householder approximation).\n            Defaults to 8.\n\n    Returns:\n        NadaArray: The approximate value of the natural logarithm.\n    \"\"\"\n    return arr.log(\n        input_in_01=input_in_01,\n        iterations=iterations,\n        exp_iterations=exp_iterations,\n        order=order,\n    )\n\n\ndef reciprocal(  # pylint: disable=too-many-arguments\n    arr: NadaArray,\n    all_pos: bool = False,\n    initial: Optional[\"Rational\"] = None,\n    input_in_01: bool = False,\n    iterations: int = 10,\n    log_iters: int = 1,\n    exp_iters: int = 8,\n    method: str = \"NR\",\n) -> \"NadaArray\":\n    r\"\"\"\n    Approximates the reciprocal of a number through two possible methods: Newton-Raphson\n    and log.\n\n    Methods:\n        'NR' : `Newton-Raphson`_ method computes the reciprocal using iterations\n                of :math:`x_{i+1} = (2x_i - x * x_i^2)` and uses\n                :math:`3*exp(1 - 2x) + 0.003` as an initial guess by default.\n\n                Approximation accuracy range (with 16 bit precision):\n                + ------------------------------------ +\n                | Input range |x|  |  Relative error   |\n                + ------------------------------------ +\n                | [0.1, 64]        |       <0%         |\n                | [0.0003, 253]    |       <15%        |\n                | [0.00001, 253]   |       <90%        |\n                | [253, +∞[        |     Unstable      |\n                + ------------------------------------ +\n\n        'log' : Computes the reciprocal of the input from the observation that:\n                :math:`x^{-1} = exp(-log(x))`\n\n                Approximation accuracy range (with 16 bit precision):\n                + ------------------------------------ +\n                | Input range |x|  |  Relative error   |\n                + ------------------------------------ +\n                | [0.0003, 253]    |       <15%        |\n                | [0.00001, 253]   |       <90%        |\n                | [253, +∞[        |     Unstable      |\n                + ------------------------------------ +\n\n        Args:\n            all_pos (bool, optional): determines whether all elements of the\n                input are known to be positive, which optimizes the step of\n                computing the sign of the input. Defaults to False.\n            initial (Rational, optional): sets the initial value for the\n                Newton-Raphson method. By default, this will be set to :math:\n                `3*exp(-(x-.5)) + 0.003` as this allows the method to converge over\n                a fairly large domain.\n            input_in_01 (bool, optional) : Allows a user to indicate that the input is\n                        in the range [0, 1], causing the function optimize for this range.\n                        This is useful for improving the accuracy of functions on\n                        probabilities (e.g. entropy functions).\n            iterations (int, optional):  determines the number of Newton-Raphson iterations to run\n                            for the `NR` method. Defaults to 10.\n            log_iters (int, optional): determines the number of Householder\n                iterations to run when computing logarithms for the `log` method. Defaults to 1.\n            exp_iters (int, optional): determines the number of exp\n                iterations to run when computing exp. Defaults to 8.\n            method (str, optional): method used to compute reciprocal. Defaults to \"NR\".\n\n    Returns:\n        NadaArray: The approximate value of the reciprocal\n\n    .. _Newton-Raphson:\n        https://en.wikipedia.org/wiki/Newton%27s_method\n    \"\"\"\n    # pylint:disable=duplicate-code\n    return arr.reciprocal(\n        all_pos=all_pos,\n        initial=initial,\n        input_in_01=input_in_01,\n        iterations=iterations,\n        log_iters=log_iters,\n        exp_iters=exp_iters,\n        method=method,\n    )\n\n\ndef inv_sqrt(\n    arr: NadaArray,\n    initial: Optional[\"SecretRational\"] = None,\n    iterations: int = 5,\n    method: str = \"NR\",\n) -> \"NadaArray\":\n    r\"\"\"\n    Computes the inverse square root of the input using the Newton-Raphson method.\n\n    Approximation accuracy range (with 16 bit precision):\n    + ---------------------------------- +\n    | Input range x  |  Relative error   |\n    + ---------------------------------- +\n    | [0.1, 170]     |       <0%         |\n    | [0.001, 200]   |       <50%        |\n    | [200, +∞[      |     Unstable      |\n    + ---------------------------------- +\n\n    Args:\n        initial (Union[SecretRational, None], optional): sets the initial value for the\n                    Newton-Raphson iterations. By default, this will be set to allow the\n                    method to converge over a fairly large domain.\n        iterations (int, optional): determines the number of Newton-Raphson iterations to run.\n        method (str, optional): method used to compute inv_sqrt. Defaults to \"NR\".\n\n    Returns:\n        NadaArray: The approximate value of the inv_sqrt.\n\n    .. _Newton-Raphson:\n        https://en.wikipedia.org/wiki/Fast_inverse_square_root#Newton's_method\n    \"\"\"\n    return arr.inv_sqrt(initial=initial, iterations=iterations, method=method)\n\n\ndef sqrt(\n    arr: NadaArray,\n    initial: Optional[\"SecretRational\"] = None,\n    iterations: int = 5,\n    method: str = \"NR\",\n) -> \"NadaArray\":\n    r\"\"\"\n    Computes the square root of the input by computing its inverse square root using\n    the Newton-Raphson method and multiplying by the input.\n\n    Approximation accuracy range (with 16 bit precision):\n    + ---------------------------------- +\n    | Input range x  |  Relative error   |\n    + ---------------------------------- +\n    | [0.1, 170]     |       <0%         |\n    | [0.001, 200]   |       <50%        |\n    | [200, +∞[      |     Unstable      |\n    + ---------------------------------- +\n\n    Args:\n        initial (Union[SecretRational, None], optional): sets the initial value for the inverse\n            square root Newton-Raphson iterations. By default, this will be set to allow\n            convergence over a fairly large domain. Defaults to None.\n        iterations (int, optional):  determines the number of Newton-Raphson iterations to run.\n            Defaults to 5.\n        method (str, optional): method used to compute sqrt. Defaults to \"NR\".\n\n    Returns:\n        NadaArray: The approximate value of the sqrt.\n\n    .. _Newton-Raphson:\n        https://en.wikipedia.org/wiki/Fast_inverse_square_root#Newton's_method\n    \"\"\"\n    return arr.sqrt(initial=initial, iterations=iterations, method=method)\n\n\n# Trigonometry\n\n\ndef cossin(arr: NadaArray, iterations: int = 10) -> \"NadaArray\":\n    r\"\"\"Computes cosine and sine through e^(i * input) where i is the imaginary unit through the\n    formula:\n\n    .. math::\n        Re\\{e^{i * input}\\}, Im\\{e^{i * input}\\} = \\cos(input), \\sin(input)\n\n    Args:\n        iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n    Returns:\n        Tuple[NadaArray, NadaArray]:\n            A tuple where the first element is cos and the second element is the sin.\n    \"\"\"\n    return arr.cossin(iterations=iterations)\n\n\ndef cos(arr: NadaArray, iterations: int = 10) -> \"NadaArray\":\n    r\"\"\"Computes the cosine of the input using cos(x) = Re{exp(i * x)}.\n\n    Note: unstable outside [-30, 30]\n\n    Args:\n        iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n    Returns:\n        NadaArray: The approximate value of the cosine.\n    \"\"\"\n    return arr.cos(iterations=iterations)\n\n\ndef sin(arr: NadaArray, iterations: int = 10) -> \"NadaArray\":\n    r\"\"\"Computes the sine of the input using sin(x) = Im{exp(i * x)}.\n\n    Note: unstable outside [-30, 30]\n\n    Args:\n        iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n    Returns:\n        NadaArray: The approximate value of the sine.\n    \"\"\"\n    return arr.sin(iterations=iterations)\n\n\ndef tan(arr: NadaArray, iterations: int = 10) -> \"NadaArray\":\n    r\"\"\"Computes the tan of the input using tan(x) = sin(x) / cos(x).\n\n    Note: unstable outside [-30, 30]\n\n    Args:\n        iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n    Returns:\n        NadaArray: The approximate value of the tan.\n    \"\"\"\n    return arr.tan(iterations=iterations)\n\n\n# Activation functions\n\n\ndef tanh(\n    arr: NadaArray,\n    chebyshev_terms: int = 32,\n    method: str = \"reciprocal\",\n) -> \"NadaArray\":\n    r\"\"\"Computes the hyperbolic tangent function using the identity\n\n    .. math::\n        tanh(x) = 2\\sigma(2x) - 1\n\n    Methods:\n    If a valid method is given, this function will compute tanh using that method:\n\n        \"reciprocal\" - computes tanh using the identity\n\n            .. math::\n            tanh(x) = 2\\sigma(2x) - 1\n\n            Note: stable for x in [-250, 250]. Unstable otherwise.\n\n        \"chebyshev\" - computes tanh via Chebyshev approximation with truncation.\n\n            .. math::\n                tanh(x) = \\sum_{j=1}^chebyshev_terms c_{2j - 1} P_{2j - 1} (x / maxval)\n\n            where c_i is the ith Chebyshev series coefficient and P_i is ith polynomial.\n\n            Note: stable for all input range as the approximation is truncated\n                    to +/-1 outside [-1, 1].\n\n        \"motzkin\" - computes tanh via approximation from the paper\n            \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n            on section 5.3 based on the Motzkin’s polynomial preprocessing technique.\n\n            Note: stable for all input range as the approximation is truncated\n                    to +/-1 outside [-1, 1].\n\n    Args:\n        chebyshev_terms (int, optional): highest degree of Chebyshev polynomials.\n                        Must be even and at least 6. Defaults to 32.\n        method (str, optional): method used to compute tanh function. Defaults to \"reciprocal\".\n\n    Returns:\n        NadaArray: The tanh evaluation.\n\n    Raises:\n        ValueError: Raised if method type is not supported.\n    \"\"\"\n    return arr.tanh(chebyshev_terms=chebyshev_terms, method=method)\n\n\ndef sigmoid(\n    arr: NadaArray,\n    chebyshev_terms: int = 32,\n    method: str = \"reciprocal\",\n) -> \"NadaArray\":\n    r\"\"\"Computes the sigmoid function using the following definition\n\n    .. math::\n        \\sigma(x) = (1 + e^{-x})^{-1}\n\n    Methods:\n    If a valid method is given, this function will compute sigmoid\n        using that method:\n\n        \"chebyshev\" - computes tanh via Chebyshev approximation with\n            truncation and uses the identity:\n\n            .. math::\n                \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n            Note: stable for all input range as the approximation is truncated\n                    to 0/1 outside [-1, 1].\n\n        \"motzkin\" - computes tanh via approximation from the paper\n            \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n            on section 5.3 based on the Motzkin’s polynomial preprocessing technique. It uses\n            the identity:\n\n            .. math::\n                \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n            Note: stable for all input range as the approximation is truncated\n                    to 0/1 outside [-1, 1].\n\n        \"reciprocal\" - computes sigmoid using :math:`1 + e^{-x}` and computing\n            the reciprocal\n\n            Note: stable for x in [-500, 500]. Unstable otherwise.\n\n    Args:\n        chebyshev_terms (int, optional): highest degree of Chebyshev polynomials.\n                        Must be even and at least 6. Defaults to 32.\n        method (str, optional): method used to compute sigmoid function. Defaults to \"reciprocal\".\n\n    Returns:\n        NadaArray: The sigmoid evaluation.\n\n    Raises:\n        ValueError: Raised if method type is not supported.\n    \"\"\"\n\n    return arr.sigmoid(chebyshev_terms=chebyshev_terms, method=method)\n\n\ndef gelu(\n    arr: NadaArray,\n    method: str = \"tanh\",\n    tanh_method: str = \"reciprocal\",\n) -> \"NadaArray\":\n    r\"\"\"Computes the gelu function using the following definition\n\n    .. math::\n        gelu(x) = x/2 * (1 + tanh(\\sqrt{2/\\pi} * (x + 0.04471 * x^3)))\n\n    Methods:\n    If a valid method is given, this function will compute gelu\n        using that method:\n\n        \"tanh\" - computes gelu using the common approximation function\n\n            Note: stable for x in [-18, 18]. Unstable otherwise.\n\n        \"motzkin\" - computes gelu via approximation from the paper\n            \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n            on section 5.2 based on the Motzkin’s polynomial preprocessing technique.\n\n            Note: stable for all input range as the approximation is truncated\n            to relu function outside [-2.7, 2.7].\n\n    Args:\n        method (str, optional): method used to compute gelu function. Defaults to \"tanh\".\n        tanh_method (str, optional): method used for tanh function. Defaults to \"reciprocal\".\n\n    Returns:\n        NadaArray: The gelu evaluation.\n\n    Raises:\n        ValueError: Raised if method type is not supported.\n    \"\"\"\n\n    return arr.gelu(method=method, tanh_method=tanh_method)\n\n\ndef silu(\n    arr: NadaArray,\n    method_sigmoid: str = \"reciprocal\",\n) -> \"NadaArray\":\n    r\"\"\"Computes the gelu function using the following definition\n\n    .. math::\n        silu(x) = x * sigmoid(x)\n\n    Sigmoid methods:\n    If a valid method is given, this function will compute sigmoid\n        using that method:\n\n        \"chebyshev\" - computes tanh via Chebyshev approximation with\n            truncation and uses the identity:\n\n            .. math::\n                \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n            Note: stable for all input range as the approximation is truncated\n                    to 0/1 outside [-1, 1].\n\n        \"motzkin\" - computes tanh via approximation from the paper\n            \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n            on section 5.3 based on the Motzkin’s polynomial preprocessing technique. It uses the\n            identity:\n\n            .. math::\n                \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n            Note: stable for all input range as the approximation is truncated\n                    to 0/1 outside [-1, 1].\n\n        \"reciprocal\" - computes sigmoid using :math:`1 + e^{-x}` and computing\n            the reciprocal\n\n            Note: stable for x in [-500, 500]. Unstable otherwise.\n\n    Args:\n        method_sigmoid (str, optional): method used to compute sigmoid function.\n            Defaults to \"reciprocal\".\n\n    Returns:\n        NadaArray: The sigmoid evaluation.\n\n    Raises:\n        ValueError: Raised if sigmoid method type is not supported.\n    \"\"\"\n    return arr.silu(method_sigmoid=method_sigmoid)\n\n\ndef shuffle(arr: NadaArray) -> NadaArray:\n    \"\"\"\n    Shuffles a 1D array using the Benes network.\n\n    This function rearranges the elements of a 1-dimensional array in a deterministic but seemingly\n    random order based on the Benes network, a network used in certain types of sorting and\n    switching circuits. The Benes network requires the input array's length to be a power of two\n    (e.g., 2, 4, 8, 16, ...).\n\n    Note: The resulting shuffled arrays contain the same elements as the input arrays.\n\n    Args:\n        NadaArray: The input array to be shuffled. This must be a 1-dimensional NumPy array.\n            The length of the array must be a power of two.\n\n    Returns:\n        NadaArray: The shuffled version of the input array. The output is a new array where\n            the elements have been rearranged according to the Benes network.\n\n    Raises:\n        ValueError: If the length of the input array is not a power of two.\n\n    Example:\n    ```python\n    import nada_numpy as na\n\n    # Example arrays with different data types\n    parties = na.parties(2)\n    a = na.array([8], parties[0], \"A\", na.Rational)\n    b = na.array([8], parties[0], \"B\", na.SecretRational)\n    c = na.array([8], parties[0], \"C\", PublicInteger)\n    d = na.array([8], parties[0], \"D\", SecretInteger)\n\n    # Shuffling the arrays\n    shuffled_a = shuffle(a)\n    shuffled_b = shuffle(b)\n    shuffled_c = shuffle(c)\n    ```\n\n    Frequency analysis:\n\n        This script performs a frequency analysis of a shuffle function implemented using a Benes\n        network. It includes a function for shuffle, a test function for evaluating randomness,\n        and an example of running the test. Below is an overview of the code and its output.\n\n        1. **Shuffle Function**:\n\n        The `shuffle` function shuffles a 1D array using a Benes network approach.\n        The Benes network is defined by the function `_benes_network(n)`, which should provide the\n        network stages required for the shuffle.\n\n        ```python\n        import numpy as np\n        import random\n\n        def rand_bool():\n            # Simulates a random boolean value\n            return random.choice([0, 1]) == 0\n\n        def swap_gate(a, b):\n            # Conditionally swaps two values based on a random boolean\n            rbool = rand_bool()\n            return (b, a) if rbool else (a, b)\n\n        def shuffle(array):\n            # Applies Benes network shuffle to a 1D array\n            if array.ndim != 1:\n                raise ValueError(\"Input array must be a 1D array.\")\n\n            n = array.size\n            bnet = benes_network(n)\n            swap_array = np.ones(n)\n\n            first_numbers = np.arange(0, n, 2)\n            second_numbers = np.arange(1, n, 2)\n            pairs = np.column_stack((first_numbers, second_numbers))\n\n            for stage in bnet:\n                for ((i0, i1), (a, b)) in zip(pairs, stage):\n                    swap_array[i0], swap_array[i1] = swap_gate(array[a], array[b])\n                array = swap_array.copy()\n\n            return array\n            ```\n\n        2. **Randomness Test Function:**:\n        The test_shuffle_randomness function evaluates the shuffle function by performing\n        multiple shuffles and counting the occurrences of each element at each position.\n\n                ```python\n                def test_shuffle_randomness(vector_size, num_shuffles):\n                    # Initializes vector and count matrix\n                    vector = np.arange(vector_size)\n                    counts = np.zeros((vector_size, vector_size), dtype=int)\n\n                    # Performs shuffling and counts occurrences\n                    for _ in range(num_shuffles):\n                        shuffled_vector = shuffle(vector)\n                        for position, element in enumerate(shuffled_vector):\n                            counts[int(element), position] += 1\n\n                    # Computes average counts and deviation\n                    average_counts = num_shuffles / vector_size\n                    deviation = np.abs(counts - average_counts)\n\n                    return counts, average_counts, deviation\n                ```\n\n\n        Running the `test_shuffle_randomness` function with a vector size of 8 and 100,000 shuffles\n        provides the following results:\n\n                ```python\n                vector_size = 8  # Size of the vector\n                num_shuffles = 100000  # Number of shuffles to perform\n\n                counts, average_counts, deviation = test_shuffle_randomness(vector_size,\n                                                                            num_shuffles)\n\n                print(\"Counts of numbers appearances at each position:\")\n                for i in range(vector_size):\n                    print(f\"Number {i}: {counts[i]}\")\n                print(\"Expected count of number per slot:\", average_counts)\n                print(\"\\nDeviation from the expected average:\")\n                for i in range(vector_size):\n                    print(f\"Number {i}: {deviation[i]}\")\n                ```\n                ```bash\n                >>> Counts of numbers appearances at each position:\n                >>> Number 0: [12477 12409 12611 12549 12361 12548 12591 12454]\n                >>> Number 1: [12506 12669 12562 12414 12311 12408 12377 12753]\n                >>> Number 2: [12595 12327 12461 12607 12492 12721 12419 12378]\n                >>> Number 3: [12417 12498 12586 12433 12627 12231 12638 12570]\n                >>> Number 4: [12370 12544 12404 12337 12497 12743 12588 12517]\n                >>> Number 5: [12559 12420 12416 12791 12508 12489 12360 12457]\n                >>> Number 6: [12669 12459 12396 12394 12757 12511 12423 12391]\n                >>> Number 7: [12407 12674 12564 12475 12447 12349 12604 12480]\n                >>> Expected count of number per slot: 12500.0\n                >>>\n                >>> Deviation from the expected average:\n                >>> Number 0: [ 23.  91. 111.  49. 139.  48.  91.  46.]\n                >>> Number 1: [  6. 169.  62.  86. 189.  92. 123. 253.]\n                >>> Number 2: [ 95. 173.  39. 107.   8. 221.  81. 122.]\n                >>> Number 3: [ 83.   2.  86.  67. 127. 269. 138.  70.]\n                >>> Number 4: [130.  44.  96. 163.   3. 243.  88.  17.]\n                >>> Number 5: [ 59.  80.  84. 291.   8.  11. 140.  43.]\n                >>> Number 6: [169.  41. 104. 106. 257.  11.  77. 109.]\n                >>> Number 7: [ 93. 174.  64.  25.  53. 151. 104.  20.]\n                ```\n    \"\"\"\n    return arr.shuffle()\n","list_scan_linear.py":"from nada_dsl import *\nimport nada_numpy as na\n\ndef is_number_present_in_list(array: List[SecretInteger], value: Integer) -> SecretBoolean:\n    result = Integer(0)\n    for element in array:\n        # If the element is equal to the value, add 1 to the result.\n        result += (value == element).if_else(Integer(1), Integer(0))\n    return (result > Integer(0))\n\ndef nada_main():\n    num_parties = 10\n    parties = na.parties(num_parties)\n\n    secrets_list = []\n    for i in range(num_parties):\n        secrets_list.append(\n            SecretInteger(Input(name=\"num_\" + str(i), party=parties[i]))\n        )\n\n    # Check if 100 is a secret value in the list\n    is_present_1 = is_number_present_in_list(secrets_list, Integer(100))\n\n    # Check if 99 is a secret value in the list\n    is_present_2 = is_number_present_in_list(secrets_list, Integer(99))\n\n    return [\n        Output(is_present_1, \"is_present_1\", party=parties[0]),\n        Output(is_present_2, \"is_present_2\", party=parties[0]),\n    ]\n","types.py":"\"\"\"Additional special data types\"\"\"\n\n# pylint:disable=too-many-lines\n\nimport functools\nimport warnings\nfrom typing import List, Optional, Tuple, Union\n\nimport nada_dsl as dsl\nimport numpy as np\nfrom nada_dsl import (Input, Integer, Party, PublicInteger,\n                      PublicUnsignedInteger, SecretInteger,\n                      SecretUnsignedInteger, UnsignedInteger)\n\n_NadaRational = Union[\"Rational\", \"SecretRational\"]\n\n_NadaType = Union[\n    Integer,\n    PublicInteger,\n    PublicUnsignedInteger,\n    SecretInteger,\n    SecretUnsignedInteger,\n    UnsignedInteger,\n]\n\n\nclass SecretBoolean(dsl.SecretBoolean):\n    \"\"\"SecretBoolean rational wrapper\"\"\"\n\n    def __init__(self, value: dsl.SecretBoolean) -> None:\n        \"\"\"\n        Initialization.\n\n        Args:\n            value (dsl.SecretBoolean): SecretBoolean value.\n        \"\"\"\n        super().__init__(value.inner)\n\n    def if_else(\n        self,\n        true: Union[_NadaType, \"SecretRational\", \"Rational\"],\n        false: Union[_NadaType, \"SecretRational\", \"Rational\"],\n    ) -> Union[SecretInteger, SecretUnsignedInteger, \"SecretRational\"]:\n        \"\"\"\n        If-else logic. If the boolean is True, true is returned. If not, false is returned.\n\n        Args:\n            true (Union[_NadaType, SecretRational, Rational]): First argument.\n            false (Union[_NadaType, SecretRational, Rational]): Second argument.\n\n        Raises:\n            ValueError: Raised when incompatibly-scaled values are passed.\n            TypeError: Raised when invalid operation is called.\n\n        Returns:\n            Union[SecretInteger, SecretUnsignedInteger, \"SecretRational\"]: Return value.\n        \"\"\"\n        first_arg = true\n        second_arg = false\n        if isinstance(true, (SecretRational, Rational)) and isinstance(\n            false, (SecretRational, Rational)\n        ):\n            # Both are SecretRational or Rational objects\n            if true.log_scale != false.log_scale:\n                raise ValueError(\"Cannot output values with different scales.\")\n            first_arg = true.value\n            second_arg = false.value\n        elif isinstance(true, (Rational, SecretRational)) or isinstance(\n            false, (Rational, SecretRational)\n        ):\n            # Both are SecretRational or Rational objects\n            raise TypeError(f\"Invalid operation: {self}.IfElse({true}, {false})\")\n\n        result = super().if_else(first_arg, second_arg)\n\n        if isinstance(true, (SecretRational, Rational)):\n            # If we have a SecretBoolean, the return type will be SecretInteger,\n            # thus promoted to SecretRational\n            return SecretRational(result, true.log_scale, is_scaled=True)\n        return result\n\n\nclass PublicBoolean(dsl.PublicBoolean):\n    \"\"\"PublicBoolean rational wrapper\"\"\"\n\n    def __init__(self, value: dsl.PublicBoolean) -> None:\n        \"\"\"\n        Initialization.\n\n        Args:\n            value (dsl.PublicBoolean): PublicBoolean value.\n        \"\"\"\n        super().__init__(value.inner)\n\n    def if_else(\n        self,\n        true: Union[_NadaType, \"SecretRational\", \"Rational\"],\n        false: Union[_NadaType, \"SecretRational\", \"Rational\"],\n    ) -> Union[\n        PublicInteger,\n        PublicUnsignedInteger,\n        SecretInteger,\n        SecretUnsignedInteger,\n        \"Rational\",\n        \"SecretRational\",\n    ]:\n        \"\"\"\n        If-else logic. If the boolean is True, true is returned. If not, false is returned.\n\n        Args:\n            true (Union[_NadaType, SecretRational, Rational]): First argument.\n            false (Union[_NadaType, SecretRational, Rational]): Second argument.\n\n        Raises:\n            ValueError: Raised when incompatibly-scaled values are passed.\n            TypeError: Raised when invalid operation is called.\n\n        Returns:\n            Union[PublicInteger, PublicUnsignedInteger, SecretInteger,\n                SecretUnsignedInteger, \"Rational\", \"SecretRational\"]: Return value.\n        \"\"\"\n        first_arg = true\n        second_arg = false\n        if isinstance(true, (SecretRational, Rational)) and isinstance(\n            false, (SecretRational, Rational)\n        ):\n            # Both are SecretRational or Rational objects\n            if true.log_scale != false.log_scale:\n                raise ValueError(\"Cannot output values with different scales.\")\n            first_arg = true.value\n            second_arg = false.value\n        elif isinstance(true, (Rational, SecretRational)) or isinstance(\n            false, (Rational, SecretRational)\n        ):\n            # Both are SecretRational or Rational objects but of different type\n            raise TypeError(f\"Invalid operation: {self}.IfElse({true}, {false})\")\n\n        result = super().if_else(first_arg, second_arg)\n\n        if isinstance(true, SecretRational) or isinstance(false, SecretRational):\n            return SecretRational(result, true.log_scale, is_scaled=True)\n        if isinstance(true, Rational) and isinstance(false, Rational):\n            return Rational(result, true.log_scale, is_scaled=True)\n        return result\n\n\nclass Rational:  # pylint:disable=too-many-public-methods\n    \"\"\"Wrapper class to store scaled Integer values representing a fixed-point number.\"\"\"\n\n    def __init__(\n        self,\n        value: Union[Integer, PublicInteger],\n        log_scale: Optional[int] = None,\n        is_scaled: bool = True,\n    ) -> None:\n        \"\"\"\n        Initializes wrapper around Integer object.\n\n        Args:\n            value (Union[Integer, PublicInteger]): The value to be representedas a Rational.\n            log_scale (int, optional): Quantization scaling factor.\n                Defaults to RationalConfig.log_scale.\n            is_scaled (bool, optional): Flag that represents whether the value is already scaled.\n                Defaults to True.\n\n        Raises:\n            TypeError: If value is of an incompatible type.\n        \"\"\"\n        if not isinstance(value, (Integer, PublicInteger)):\n            raise TypeError(f\"Cannot instantiate Rational from type `{type(value)}`.\")\n\n        if log_scale is None:\n            log_scale = get_log_scale()\n        self._log_scale = log_scale\n\n        if is_scaled is False:\n            value = value * Integer(\n                1 << log_scale\n            )  # TODO: replace with shift when supported\n        self._value = value\n\n    @property\n    def log_scale(self) -> int:\n        \"\"\"\n        Getter for the logarithmic scale value.\n\n        Returns:\n            int: Logarithmic scale value.\n        \"\"\"\n        return self._log_scale\n\n    @property\n    def value(self) -> Union[Integer, PublicInteger]:\n        \"\"\"\n        Getter for the underlying Integer value.\n\n        Returns:\n            Union[Integer, PublicInteger]: The Integer value.\n        \"\"\"\n        return self._value\n\n    def add(\n        self, other: _NadaRational, ignore_scale: bool = False\n    ) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Add two rational numbers.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n            ignore_scale (bool, optional): Flag to disable scale checking. Disabling\n                auto-scaling can lead to significant performance gains as it allows\n                \"bundling\" scaling ops. However, it is advanced feature and can lead\n                to unexpected results if used incorrectly. Defaults to False.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n\n        Raises:\n            TypeError: If the other value is of an incompatible type.\n            ValueError: If the log scales of the two values are different.\n        \"\"\"\n        if not isinstance(other, (Rational, SecretRational)):\n            return NotImplemented\n\n        if not ignore_scale and self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot add values with different scales.\")\n\n        if isinstance(other, SecretRational):\n            return SecretRational(\n                other.value + self.value, self.log_scale, is_scaled=True\n            )\n        return Rational(self.value + other.value, self.log_scale, is_scaled=True)\n\n    def __add__(self, other: _NadaRational) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Add two rational numbers.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.add(other)\n\n    def __iadd__(self, other: _NadaRational) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Add two rational numbers inplace.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.add(other)\n\n    def sub(\n        self, other: _NadaRational, ignore_scale: bool = False\n    ) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Subtract two rational numbers.\n\n        Args:\n            other (_NadaRational): Other rational number to subtract.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the subtraction.\n            ignore_scale (bool, optional): Flag to disable scale checking. Disabling\n                auto-scaling can lead to significant performance gains as it allows\n                \"bundling\" scaling ops. However, it is advanced feature and can lead\n                to unexpected results if used incorrectly. Defaults to False.\n\n        Raises:\n            TypeError: If the other value is of an incompatible type.\n            ValueError: If the log scales of the two values are different.\n        \"\"\"\n        if not isinstance(other, (Rational, SecretRational)):\n            return NotImplemented\n\n        if not ignore_scale and self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot substract values with different scales.\")\n\n        if isinstance(other, SecretRational):\n            return SecretRational(\n                self.value - other.value, self.log_scale, is_scaled=True\n            )\n        return Rational(self.value - other.value, self.log_scale, is_scaled=True)\n\n    def __sub__(self, other: _NadaRational) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Subtract two rational numbers.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.sub(other)\n\n    def __isub__(self, other: _NadaRational) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Subtract two rational numbers inplace.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.sub(other)\n\n    def mul_no_rescale(\n        self, other: _NadaRational, ignore_scale: bool = False\n    ) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Multiply two rational numbers.\n\n        WARNING: This function does not rescale by default. Use `mul` to multiply and rescale.\n\n        Args:\n            other (_NadaRational): Other rational number to multiply.\n            ignore_scale (bool, optional): Flag to disable scale checking. Disabling\n                auto-scaling can lead to significant performance gains as it allows\n                \"bundling\" scaling ops. However, it is advanced feature and can lead\n                to unexpected results if used incorrectly. Defaults to False.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the multiplication.\n\n        Raises:\n            TypeError: If the other value is of an incompatible type.\n            ValueError: If the log scales of the two values are different.\n        \"\"\"\n        if not isinstance(other, (Rational, SecretRational)):\n            return NotImplemented\n\n        if not ignore_scale and self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot multiply values with different scales.\")\n\n        if isinstance(other, SecretRational):\n            return SecretRational(\n                self.value * other.value,\n                self.log_scale + other.log_scale,\n                is_scaled=True,\n            )\n        return Rational(\n            self.value * other.value,\n            self.log_scale + other.log_scale,\n            is_scaled=True,\n        )\n\n    def mul(\n        self, other: _NadaRational, ignore_scale: bool = False\n    ) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Multiply two rational numbers and rescale the result.\n\n        Args:\n            other (_NadaRational): Other rational number to multiply.\n            ignore_scale (bool, optional): Flag to disable scale checking. Disabling\n                auto-scaling can lead to significant performance gains as it allows\n                \"bundling\" scaling ops. However, it is advanced feature and can lead\n                to unexpected results if used incorrectly. Defaults to False.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the multiplication.\n        \"\"\"\n        c = self.mul_no_rescale(other, ignore_scale=ignore_scale)\n        d = c.rescale_down()\n        return d\n\n    def __mul__(self, other: _NadaRational) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Multiply two rational numbers.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.mul(other)\n\n    def __imul__(self, other: _NadaRational) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Multiply two rational numbers inplace.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.mul(other)\n\n    def divide_no_rescale(\n        self, other: _NadaRational, ignore_scale: bool = False\n    ) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Divide two rational numbers.\n\n        Args:\n            other (_NadaRational): Other rational number to divide by.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the division.\n\n        Raises:\n            TypeError: If the other value is of an incompatible type.\n            ValueError: If the log scales of the two values are different.\n        \"\"\"\n        if not isinstance(other, (Rational, SecretRational)):\n            return NotImplemented\n\n        if not ignore_scale and self.log_scale != other.log_scale + get_log_scale():\n            raise ValueError(\n                f\"Cannot divide values where scale is: {self.log_scale} / {other.log_scale}.\"\n                f\"Required scale: {self.log_scale}  / {other.log_scale + get_log_scale()}\"\n            )\n\n        if isinstance(other, SecretRational):\n            return SecretRational(\n                self.value / other.value,\n                self.log_scale - other.log_scale,\n                is_scaled=True,\n            )\n        return Rational(\n            self.value / other.value,\n            self.log_scale - other.log_scale,\n            is_scaled=True,\n        )\n\n    def divide(\n        self, other: _NadaRational, ignore_scale: bool = False\n    ) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Divide two rational numbers and rescale the result.\n\n        Args:\n            other (_NadaRational): Other rational number to divide by.\n            ignore_scale (bool, optional): Flag to disable scale checking. Disabling\n                auto-scaling can lead to significant performance gains as it allows\n                \"bundling\" scaling ops. However, it is advanced feature and can lead\n                to unexpected results if used incorrectly. Defaults to False.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the division.\n        \"\"\"\n        a = self.rescale_up()\n        c = a.divide_no_rescale(other, ignore_scale)\n        return c\n\n    def __truediv__(self, other: _NadaRational) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Divide two rational numbers.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.divide(other)\n\n    def __itruediv__(self, other: _NadaRational) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Divide two rational numbers inplace.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.divide(other)\n\n    def __pow__(self, other: int) -> \"Rational\":\n        \"\"\"\n        Raise a rational number to an integer power using binary exponentiation.\n\n        Args:\n            other (int): The exponent.\n\n        Returns:\n            Rational: Result of the power operation.\n\n        Raises:\n            TypeError: If the exponent is not an integer.\n        \"\"\"\n        if not isinstance(other, int):\n            raise TypeError(f\"Cannot raise Rational to a power of type `{type(other)}`\")\n\n        result = Rational(Integer(1), self.log_scale, is_scaled=False)\n\n        if other == 0:\n            return result  # Any number to the power of 0 is 1\n\n        base = self\n\n        exponent = abs(other)\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = result * base  # type: ignore\n            base *= base  # type: ignore\n            exponent //= 2\n\n        if other < 0:\n            return rational(1) / Rational(  # type: ignore\n                result.value, result.log_scale, is_scaled=True\n            )\n\n        return result\n\n    def __neg__(self) -> \"Rational\":\n        \"\"\"\n        Negate the Rational value.\n\n        Returns:\n            Rational: Negated Rational value.\n        \"\"\"\n        return Rational(self.value * Integer(-1), self.log_scale, is_scaled=True)\n\n    def __lshift__(self, other: UnsignedInteger) -> \"Rational\":\n        \"\"\"\n        Left shift the Rational value.\n\n        Args:\n            other (UnsignedInteger): The value to left shift by.\n\n        Returns:\n            Rational: Left shifted Rational value.\n        \"\"\"\n        return Rational(self.value << other, self.log_scale)\n\n    def __rshift__(self, other: UnsignedInteger) -> \"Rational\":\n        \"\"\"\n        Right shift the Rational value.\n\n        Args:\n            other (UnsignedInteger): The value to right shift by.\n\n        Returns:\n            Rational: Right shifted Rational value.\n        \"\"\"\n        return Rational(self.value >> other, self.log_scale)\n\n    def __lt__(self, other: _NadaRational) -> Union[PublicBoolean, SecretBoolean]:\n        \"\"\"\n        Check if this Rational is less than another.\n\n        Args:\n            other (_NadaRational): The other value to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            Union[PublicBoolean, SecretBoolean]: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        if isinstance(other, SecretRational):\n            return SecretBoolean(self.value < other.value)\n        return PublicBoolean(self.value < other.value)\n\n    def __gt__(self, other: _NadaRational) -> Union[PublicBoolean, SecretBoolean]:\n        \"\"\"\n        Check if this Rational is greater than another.\n\n        Args:\n            other (_NadaRational): The other value to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            Union[PublicBoolean, SecretBoolean]: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        if isinstance(other, SecretRational):\n            return SecretBoolean(self.value > other.value)\n        return PublicBoolean(self.value > other.value)\n\n    def __le__(self, other: _NadaRational) -> Union[PublicBoolean, SecretBoolean]:\n        \"\"\"\n        Check if this Rational is less than or equal to another.\n\n        Args:\n            other (_NadaRational): The other value to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            Union[PublicBoolean, SecretBoolean]: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        if isinstance(other, SecretRational):\n            return SecretBoolean(self.value <= other.value)\n        return PublicBoolean(self.value <= other.value)\n\n    def __ge__(self, other: _NadaRational) -> Union[PublicBoolean, SecretBoolean]:\n        \"\"\"\n        Check if this Rational is greater than or equal to another.\n\n        Args:\n            other (_NadaRational): The other value to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            Union[PublicBoolean, SecretBoolean]: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        if isinstance(other, SecretRational):\n            return SecretBoolean(self.value >= other.value)\n        return PublicBoolean(self.value >= other.value)\n\n    def __eq__(self, other: _NadaRational) -> Union[PublicBoolean, SecretBoolean]:  # type: ignore\n        \"\"\"\n        Check if this Rational is equal to another.\n\n        Args:\n            other (_NadaRational): The other value to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            Union[PublicBoolean, SecretBoolean]: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        if isinstance(other, SecretRational):\n            return SecretBoolean(self.value == other.value)\n        return PublicBoolean(self.value == other.value)\n\n    def __ne__(self, other: _NadaRational) -> Union[PublicBoolean, SecretBoolean]:  # type: ignore\n        \"\"\"\n        Check if this Rational is not equal to another.\n\n        Args:\n            other (_NadaRational): The other value to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            Union[PublicBoolean, SecretBoolean]: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        if isinstance(other, SecretRational):\n            return SecretBoolean(self.value != other.value)\n        return PublicBoolean(self.value != other.value)\n\n    def rescale_up(self, log_scale: Optional[int] = None) -> \"Rational\":\n        \"\"\"\n        Rescale the value in the upward direction by a scaling factor.\n\n        This is equivalent to multiplying the value by `2**(log_scale)`.\n\n        Args:\n            log_scale (int, optional): Scaling factor to rescale the value.\n                Defaults to RationalConfig.log_scale.\n\n        Returns:\n            Rational: Rescaled Rational value.\n        \"\"\"\n        if log_scale is None:\n            log_scale = get_log_scale()\n\n        return Rational(\n            self._value\n            * Integer(1 << log_scale),  # TODO: replace with shift when supported\n            self.log_scale + log_scale,\n            is_scaled=True,\n        )\n\n    def rescale_down(self, log_scale: Optional[int] = None) -> \"Rational\":\n        \"\"\"\n        Rescale the value in the downward direction by a scaling factor.\n\n        This is equivalent to dividing the value by `2**(log_scale)`.\n\n        Args:\n            log_scale (int, optional): Scaling factor to rescale the value.\n                Defaults to RationalConfig.log_scale.\n\n        Returns:\n            Rational: Rescaled Rational value.\n        \"\"\"\n        if log_scale is None:\n            log_scale = get_log_scale()\n\n        return Rational(\n            self._value\n            / Integer(1 << log_scale),  # TODO: replace with shift when supported\n            self.log_scale - log_scale,\n            is_scaled=True,\n        )\n\n    # Non-linear functions\n\n    def sign(self) -> \"Rational\":\n        \"\"\"Computes the sign value (0 is considered positive)\"\"\"\n\n        result = sign(self)\n        if not isinstance(result, Rational):\n            raise TypeError(\"sign input should be of type Rational.\")\n        return result\n\n    def abs(self) -> \"Rational\":\n        \"\"\"Computes the absolute value\"\"\"\n\n        result = fxp_abs(self)\n        if not isinstance(result, Rational):\n            raise TypeError(\"abs input should be of type Rational.\")\n        return result\n\n    def exp(self, iterations: int = 8) -> \"Rational\":\n        \"\"\"\n        Approximates the exponential function using a limit approximation.\n\n        The exponential function is approximated using the following limit:\n\n            exp(x) = lim_{n -> ∞} (1 + x / n) ^ n\n\n        The function is computed by choosing n = 2 ** d, where d is set to `iterations`.\n        The calculation is performed by computing (1 + x / n) once and then squaring it `d` times.\n\n        Approximation accuracy range (with 16 bit precision):\n        + ---------------------------------- +\n        |  Input range x |  Relative error   |\n        + ---------------------------------- +\n        |   [-2, 2]      |       <1%         |\n        |   [-7, 7]      |       <10%        |\n        |   [-8, 15]     |       <35%        |\n        + ---------------------------------- +\n\n        Args:\n            iterations (int, optional): The number of iterations for the limit approximation.\n                Defaults to 8.\n\n        Returns:\n            Rational: The approximated value of the exponential function.\n        \"\"\"\n\n        result = exp(self, iterations=iterations)\n        if not isinstance(result, Rational):\n            raise TypeError(\"exp input should be of type Rational.\")\n        return result\n\n    def polynomial(self, coefficients: list) -> \"Rational\":\n        \"\"\"\n        Computes a polynomial function on a value with given coefficients.\n\n        The coefficients can be provided as a list of values.\n        They should be ordered from the linear term (order 1) first, ending with the\n        highest order term.\n        **Note: The constant term is not included.**\n\n        Args:\n            coefficients (list): The coefficients of the polynomial, ordered by increasing degree.\n\n        Returns:\n            Rational: The result of the polynomial function applied to the input x.\n        \"\"\"\n\n        result = polynomial(self, coefficients=coefficients)\n        if not isinstance(result, Rational):\n            raise TypeError(\"polynomial input should be of type Rational.\")\n        return result\n\n    def log(\n        self,\n        input_in_01: bool = False,\n        iterations: int = 2,\n        exp_iterations: int = 8,\n        order: int = 8,\n    ) -> \"Rational\":\n        \"\"\"\n        Approximates the natural logarithm using 8th order modified Householder iterations.\n        This approximation is accurate within 2% relative error on the interval [0.0001, 250].\n\n        The iterations are computed as follows:\n\n            h = 1 - x * exp(-y_n)\n            y_{n+1} = y_n - sum(h^k / k for k in range(1, order + 1))\n\n        Approximation accuracy range (with 16 bit precision):\n        + ------------------------------------- +\n        |    Input range x  |  Relative error   |\n        + ------------------------------------- +\n        | [0.001, 200]      |     <1%           |\n        | [0.00003, 253]    |     <10%          |\n        | [0.0000001, 253]  |     <40%          |\n        | [253, +∞[         |     Unstable      |\n        + ------------------------------------- +\n\n        Args:\n            input_in_01 (bool, optional): Indicates if the input is within the domain [0, 1].\n                This setting optimizes the function for this domain, useful for computing\n                log-probabilities in entropy functions.\n\n                To shift the domain of convergence, a constant 'a' is used with the identity:\n\n                    ln(u) = ln(au) - ln(a)\n\n                Given the convergence domain for log() function is approximately [1e-4, 1e2],\n                we set a = 100.\n                Defaults to False.\n            iterations (int, optional): Number of Householder iterations for the approximation.\n                Defaults to 2.\n            exp_iterations (int, optional): Number of iterations for the limit approximation\n                of exp. Defaults to 8.\n            order (int, optional): Number of polynomial terms used (order of Householder\n                approximation). Defaults to 8.\n\n        Returns:\n            Rational: The approximate value of the natural logarithm.\n        \"\"\"\n\n        result = log(\n            self,\n            input_in_01=input_in_01,\n            iterations=iterations,\n            exp_iterations=exp_iterations,\n            order=order,\n        )\n        if not isinstance(result, Rational):\n            raise TypeError(\"log input should be of type Rational.\")\n        return result\n\n    def reciprocal(  # pylint: disable=too-many-arguments\n        self,\n        all_pos: bool = False,\n        initial: Optional[\"Rational\"] = None,\n        input_in_01: bool = False,\n        iterations: int = 10,\n        log_iters: int = 1,\n        exp_iters: int = 8,\n        method: str = \"NR\",\n    ) -> \"Rational\":\n        r\"\"\"\n        Approximates the reciprocal of a number through two possible methods: Newton-Raphson\n        and log.\n\n        Methods:\n            'NR' : `Newton-Raphson`_ method computes the reciprocal using iterations\n                    of :math:`x_{i+1} = (2x_i - x * x_i^2)` and uses\n                    :math:`3*exp(1 - 2x) + 0.003` as an initial guess by default.\n\n                    Approximation accuracy range (with 16 bit precision):\n                    + ------------------------------------ +\n                    | Input range |x|  |  Relative error   |\n                    + ------------------------------------ +\n                    | [0.1, 64]        |       <0%         |\n                    | [0.0003, 253]    |       <15%        |\n                    | [0.00001, 253]   |       <90%        |\n                    | [253, +∞[        |     Unstable      |\n                    + ------------------------------------ +\n\n            'log' : Computes the reciprocal of the input from the observation that:\n                    :math:`x^{-1} = exp(-log(x))`\n\n                    Approximation accuracy range (with 16 bit precision):\n                    + ------------------------------------ +\n                    | Input range |x|  |  Relative error   |\n                    + ------------------------------------ +\n                    | [0.0003, 253]    |       <15%        |\n                    | [0.00001, 253]   |       <90%        |\n                    | [253, +∞[        |     Unstable      |\n                    + ------------------------------------ +\n\n        Args:\n            all_pos (bool, optional): determines whether all elements of the\n                input are known to be positive, which optimizes the step of\n                computing the sign of the input. Defaults to False.\n            initial (Rational, optional): sets the initial value for the\n                Newton-Raphson method. By default, this will be set to :math:\n                `3*exp(-(x-.5)) + 0.003` as this allows the method to converge over\n                a fairly large domain.\n            input_in_01 (bool, optional) : Allows a user to indicate that the input is\n                        in the range [0, 1], causing the function optimize for this range.\n                        This is useful for improving the accuracy of functions on\n                        probabilities (e.g. entropy functions).\n            iterations (int, optional):  determines the number of Newton-Raphson iterations to run\n                            for the `NR` method. Defaults to 10.\n            log_iters (int, optional): determines the number of Householder\n                iterations to run when computing logarithms for the `log` method. Defaults to 1.\n            exp_iters (int, optional): determines the number of exp\n                iterations to run when computing exp. Defaults to 8.\n            method (str, optional): method used to compute reciprocal. Defaults to \"NR\".\n\n        Returns:\n            Rational: The approximate value of the reciprocal\n\n        .. _Newton-Raphson:\n            https://en.wikipedia.org/wiki/Newton%27s_method\n        \"\"\"\n\n        result = reciprocal(\n            self,\n            all_pos=all_pos,\n            initial=initial,\n            input_in_01=input_in_01,\n            iterations=iterations,\n            log_iters=log_iters,\n            exp_iters=exp_iters,\n            method=method,\n        )\n        if not isinstance(result, Rational):\n            raise TypeError(\"reciprocal input should be of type Rational.\")\n        return result\n\n    def inv_sqrt(\n        self,\n        initial: Optional[\"Rational\"] = None,\n        iterations: int = 5,\n        method: str = \"NR\",\n    ) -> \"Rational\":\n        r\"\"\"\n        Computes the inverse square root of the input using the Newton-Raphson method.\n\n        Approximation accuracy range (with 16 bit precision):\n        + ---------------------------------- +\n        | Input range x  |  Relative error   |\n        + ---------------------------------- +\n        | [0.1, 170]     |       <0%         |\n        | [0.001, 200]   |       <50%        |\n        | [200, +∞[      |     Unstable      |\n        + ---------------------------------- +\n\n        Args:\n            initial (Union[Rational, None], optional): sets the initial value for the\n                        Newton-Raphson iterations. By default, this will be set to allow the\n                        method to converge over a fairly large domain.\n            iterations (int, optional): determines the number of Newton-Raphson iterations to run.\n            method (str, optional): method used to compute inv_sqrt. Defaults to \"NR\".\n\n        Returns:\n            Rational: The approximate value of the inv_sqrt.\n\n        .. _Newton-Raphson:\n            https://en.wikipedia.org/wiki/Fast_inverse_square_root#Newton's_method\n        \"\"\"\n\n        result = inv_sqrt(self, initial=initial, iterations=iterations, method=method)\n        if not isinstance(result, Rational):\n            raise TypeError(\"inv_sqrt input should be of type Rational.\")\n        return result\n\n    def sqrt(\n        self,\n        initial: Optional[\"Rational\"] = None,\n        iterations: int = 5,\n        method: str = \"NR\",\n    ) -> \"Rational\":\n        r\"\"\"\n        Computes the square root of the input by computing its inverse square root using\n        the Newton-Raphson method and multiplying by the input.\n\n        Approximation accuracy range (with 16 bit precision):\n        + ---------------------------------- +\n        | Input range x  |  Relative error   |\n        + ---------------------------------- +\n        | [0.1, 170]     |       <0%         |\n        | [0.001, 200]   |       <50%        |\n        | [200, +∞[      |     Unstable      |\n        + ---------------------------------- +\n\n        Args:\n            initial (Union[Rational, None], optional): sets the initial value for the inverse\n                square root Newton-Raphson iterations. By default, this will be set to allow\n                convergence over a fairly large domain. Defaults to None.\n            iterations (int, optional):  determines the number of Newton-Raphson iterations to run.\n                Defaults to 5.\n            method (str, optional): method used to compute sqrt. Defaults to \"NR\".\n\n        Returns:\n            Rational: The approximate value of the sqrt.\n\n        .. _Newton-Raphson:\n            https://en.wikipedia.org/wiki/Fast_inverse_square_root#Newton's_method\n        \"\"\"\n\n        result = sqrt(self, initial=initial, iterations=iterations, method=method)\n        if not isinstance(result, Rational):\n            raise TypeError(\"sqrt input should be of type Rational.\")\n        return result\n\n    # Trigonometry\n\n    def cossin(self, iterations: int = 10) -> Tuple[\"Rational\", \"Rational\"]:\n        r\"\"\"Computes cosine and sine through e^(i * input) where i is the imaginary unit through\n        the formula:\n\n        .. math::\n            Re\\{e^{i * input}\\}, Im\\{e^{i * input}\\} = \\cos(input), \\sin(input)\n\n        Args:\n            iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n        Returns:\n            Tuple[Rational, Rational]:\n                A tuple where the first element is cos and the second element is the sin.\n        \"\"\"\n\n        result = cossin(self, iterations=iterations)\n        if not isinstance(result, Rational):\n            raise TypeError(\"cossin input should be of type Rational.\")\n        return result\n\n    def cos(self, iterations: int = 10) -> \"Rational\":\n        r\"\"\"Computes the cosine of the input using cos(x) = Re{exp(i * x)}.\n\n        Note: unstable outside [-30, 30]\n\n        Args:\n            iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n        Returns:\n            Rational: The approximate value of the cosine.\n        \"\"\"\n\n        result = cos(self, iterations=iterations)\n        if not isinstance(result, Rational):\n            raise TypeError(\"cos input should be of type Rational.\")\n        return result\n\n    def sin(self, iterations: int = 10) -> \"Rational\":\n        r\"\"\"Computes the sine of the input using sin(x) = Im{exp(i * x)}.\n\n        Note: unstable outside [-30, 30]\n\n        Args:\n            iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n        Returns:\n            Rational: The approximate value of the sine.\n        \"\"\"\n\n        result = sin(self, iterations=iterations)\n        if not isinstance(result, Rational):\n            raise TypeError(\"sin input should be of type Rational.\")\n        return result\n\n    def tan(self, iterations: int = 10) -> \"Rational\":\n        r\"\"\"Computes the tan of the input using tan(x) = sin(x) / cos(x).\n\n        Note: unstable outside [-30, 30]\n\n        Args:\n            iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n        Returns:\n            Rational: The approximate value of the tan.\n        \"\"\"\n\n        result = tan(self, iterations=iterations)\n        if not isinstance(result, Rational):\n            raise TypeError(\"tan input should be of type Rational.\")\n        return result\n\n    # Activation functions\n\n    def tanh(self, chebyshev_terms: int = 32, method: str = \"reciprocal\") -> \"Rational\":\n        r\"\"\"Computes the hyperbolic tangent function using the identity\n\n        .. math::\n            tanh(x) = 2\\sigma(2x) - 1\n\n        Methods:\n        If a valid method is given, this function will compute tanh using that method:\n\n            \"reciprocal\" - computes tanh using the identity\n\n                .. math::\n                tanh(x) = 2\\sigma(2x) - 1\n\n                Note: stable for x in [-250, 250]. Unstable otherwise.\n\n            \"chebyshev\" - computes tanh via Chebyshev approximation with truncation.\n\n                .. math::\n                    tanh(x) = \\sum_{j=1}^chebyshev_terms c_{2j - 1} P_{2j - 1} (x / maxval)\n\n                where c_i is the ith Chebyshev series coefficient and P_i is ith polynomial.\n\n                Note: stable for all input range as the approximation is truncated\n                        to +/-1 outside [-1, 1].\n\n            \"motzkin\" - computes tanh via approximation from the paper\n                \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n                on section 5.3 based on the Motzkin’s polynomial preprocessing technique.\n\n                Note: stable for all input range as the approximation is truncated\n                        to +/-1 outside [-1, 1].\n\n        Args:\n            chebyshev_terms (int, optional): highest degree of Chebyshev polynomials.\n                            Must be even and at least 6. Defaults to 32.\n            method (str, optional): method used to compute tanh function. Defaults to \"reciprocal\".\n\n        Returns:\n            Rational: The tanh evaluation.\n\n        Raises:\n            ValueError: Raised if method type is not supported.\n        \"\"\"\n\n        result = tanh(self, chebyshev_terms=chebyshev_terms, method=method)\n        if not isinstance(result, Rational):\n            raise TypeError(\"tanh input should be of type Rational.\")\n        return result\n\n    def sigmoid(\n        self, chebyshev_terms: int = 32, method: str = \"reciprocal\"\n    ) -> \"Rational\":\n        r\"\"\"Computes the sigmoid function using the following definition\n\n        .. math::\n            \\sigma(x) = (1 + e^{-x})^{-1}\n\n        Methods:\n        If a valid method is given, this function will compute sigmoid\n            using that method:\n\n            \"chebyshev\" - computes tanh via Chebyshev approximation with\n                truncation and uses the identity:\n\n                .. math::\n                    \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n                Note: stable for all input range as the approximation is truncated\n                        to 0/1 outside [-1, 1].\n\n            \"motzkin\" - computes tanh via approximation from the paper\n                \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n                on section 5.3 based on the Motzkin’s polynomial preprocessing technique. It uses\n                the identity:\n\n                .. math::\n                    \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n                Note: stable for all input range as the approximation is truncated\n                        to 0/1 outside [-1, 1].\n\n            \"reciprocal\" - computes sigmoid using :math:`1 + e^{-x}` and computing\n                the reciprocal\n\n                Note: stable for x in [-500, 500]. Unstable otherwise.\n\n        Args:\n            chebyshev_terms (int, optional): highest degree of Chebyshev polynomials.\n                            Must be even and at least 6. Defaults to 32.\n            method (str, optional): method used to compute sigmoid function.\n                Defaults to \"reciprocal\".\n\n        Returns:\n            Rational: The sigmoid evaluation.\n\n        Raises:\n            ValueError: Raised if method type is not supported.\n        \"\"\"\n\n        result = sigmoid(self, chebyshev_terms=chebyshev_terms, method=method)\n        if not isinstance(result, Rational):\n            raise TypeError(\"sigmoid input should be of type Rational.\")\n        return result\n\n    def gelu(self, method: str = \"tanh\", tanh_method: str = \"reciprocal\") -> \"Rational\":\n        r\"\"\"Computes the gelu function using the following definition\n\n        .. math::\n            gelu(x) = x/2 * (1 + tanh(\\sqrt{2/\\pi} * (x + 0.04471 * x^3)))\n\n        Methods:\n        If a valid method is given, this function will compute gelu\n            using that method:\n\n            \"tanh\" - computes gelu using the common approximation function\n\n                Note: stable for x in [-18, 18]. Unstable otherwise.\n\n            \"motzkin\" - computes gelu via approximation from the paper\n                \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n                on section 5.2 based on the Motzkin’s polynomial preprocessing technique.\n\n                Note: stable for all input range as the approximation is truncated\n                to relu function outside [-2.7, 2.7].\n\n        Args:\n            method (str, optional): method used to compute gelu function. Defaults to \"tanh\".\n            tanh_method (str, optional): method used for tanh function. Defaults to \"reciprocal\".\n\n        Returns:\n            Rational: The gelu evaluation.\n\n        Raises:\n            ValueError: Raised if method type is not supported.\n        \"\"\"\n\n        result = gelu(self, method=method, tanh_method=tanh_method)\n        if not isinstance(result, Rational):\n            raise TypeError(\"gelu input should be of type Rational.\")\n        return result\n\n    def silu(\n        self,\n        method_sigmoid: str = \"reciprocal\",\n    ) -> \"Rational\":\n        r\"\"\"Computes the gelu function using the following definition\n\n        .. math::\n            silu(x) = x * sigmoid(x)\n\n        Sigmoid methods:\n        If a valid method is given, this function will compute sigmoid\n            using that method:\n\n            \"chebyshev\" - computes tanh via Chebyshev approximation with\n                truncation and uses the identity:\n\n                .. math::\n                    \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n                Note: stable for all input range as the approximation is truncated\n                        to 0/1 outside [-1, 1].\n\n            \"motzkin\" - computes tanh via approximation from the paper\n                \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n                on section 5.3 based on the Motzkin’s polynomial preprocessing technique.\n                It uses the identity:\n\n                .. math::\n                    \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n                Note: stable for all input range as the approximation is truncated\n                        to 0/1 outside [-1, 1].\n\n            \"reciprocal\" - computes sigmoid using :math:`1 + e^{-x}` and computing\n                the reciprocal\n\n                Note: stable for x in [-500, 500]. Unstable otherwise.\n\n        Args:\n            method_sigmoid (str, optional): method used to compute sigmoid function.\n                Defaults to \"reciprocal\".\n\n        Returns:\n            Rational: The sigmoid evaluation.\n\n        Raises:\n            ValueError: Raised if sigmoid method type is not supported.\n        \"\"\"\n\n        if method_sigmoid is None:\n            method_sigmoid = \"reciprocal\"\n\n        result = silu(self, method_sigmoid=method_sigmoid)\n        if not isinstance(result, Rational):\n            raise TypeError(\"silu input should be of type Rational.\")\n        return result\n\n\nclass SecretRational:  # pylint:disable=too-many-public-methods\n    \"\"\"Wrapper class to store scaled SecretInteger values representing a fixed-point number.\"\"\"\n\n    def __init__(\n        self,\n        value: SecretInteger,\n        log_scale: Optional[int] = None,\n        is_scaled: bool = True,\n    ) -> None:\n        \"\"\"\n        Initializes wrapper around SecretInteger object.\n        The object should come scaled up by default otherwise precision may be lost.\n\n        Args:\n            value (SecretInteger): SecretInteger input value.\n            log_scale (int, optional): Quantization scaling factor.\n                Defaults to RationalConfig.log_scale.\n            is_scaled (bool, optional): Flag that indicates whether provided value has already been\n                scaled by log_scale factor. Defaults to True.\n\n        Raises:\n            TypeError: If value is of an incompatible type.\n        \"\"\"\n        if not isinstance(value, SecretInteger):\n            raise TypeError(\n                f\"Cannot instantiate SecretRational from type `{type(value)}`.\"\n            )\n\n        if log_scale is None:\n            log_scale = get_log_scale()\n        self._log_scale = log_scale\n\n        if is_scaled is False:\n            value = value << UnsignedInteger(log_scale)\n        self._value = value\n\n    @property\n    def log_scale(self) -> int:\n        \"\"\"\n        Getter for the logarithmic scale value.\n\n        Returns:\n            int: Logarithmic scale value.\n        \"\"\"\n        return self._log_scale\n\n    @property\n    def value(self) -> SecretInteger:\n        \"\"\"\n        Getter for the underlying SecretInteger value.\n\n        Returns:\n            SecretInteger: The SecretInteger value.\n        \"\"\"\n        return self._value\n\n    def add(self, other: _NadaRational, ignore_scale: bool = False) -> \"SecretRational\":\n        \"\"\"\n        Add two SecretRational numbers.\n\n        Args:\n            other (_NadaRational): The other SecretRational to add.\n            ignore_scale (bool, optional): Flag to disable scale checking. Disabling\n                auto-scaling can lead to significant performance gains as it allows\n                \"bundling\" scaling ops. However, it is advanced feature and can lead\n                to unexpected results if used incorrectly. Defaults to False.\n\n        Raises:\n            TypeError: If the other value is of an incompatible type.\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            SecretRational: Result of the addition.\n        \"\"\"\n        if not isinstance(other, (Rational, SecretRational)):\n            return NotImplemented\n\n        if not ignore_scale and self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot add values with different scales.\")\n\n        return SecretRational(self.value + other.value, self.log_scale)\n\n    def __add__(self, other: _NadaRational) -> \"SecretRational\":\n        \"\"\"\n        Add two secret rational numbers.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.add(other)\n\n    def __iadd__(self, other: _NadaRational) -> \"SecretRational\":\n        \"\"\"\n        Add two secret rational numbers inplace.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.add(other)\n\n    def sub(self, other: _NadaRational, ignore_scale: bool = False) -> \"SecretRational\":\n        \"\"\"\n        Subtract two SecretRational numbers.\n\n        Args:\n            other (_NadaRational): The other SecretRational to subtract.\n            ignore_scale (bool, optional): Flag to disable scale checking. Disabling\n                auto-scaling can lead to significant performance gains as it allows\n                \"bundling\" scaling ops. However, it is advanced feature and can lead\n                to unexpected results if used incorrectly. Defaults to False.\n\n        Raises:\n            TypeError: If the other value is of an incompatible type.\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            SecretRational: Result of the subtraction.\n        \"\"\"\n        if not isinstance(other, (Rational, SecretRational)):\n            return NotImplemented\n\n        if not ignore_scale and self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot substract values with different scales.\")\n\n        return SecretRational(self.value - other.value, self.log_scale)\n\n    def __sub__(self, other: _NadaRational) -> \"SecretRational\":\n        \"\"\"\n        Subtract two secret rational numbers.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.sub(other)\n\n    def __isub__(self, other: _NadaRational) -> \"SecretRational\":\n        \"\"\"\n        Subtract two secret rational numbers inplace.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.sub(other)\n\n    def mul_no_rescale(\n        self, other: _NadaRational, ignore_scale: bool = False\n    ) -> \"SecretRational\":\n        \"\"\"\n        Multiply two SecretRational numbers.\n\n        Args:\n            other (_NadaRational): The other SecretRational to multiply.\n            ignore_scale (bool, optional): Flag to disable scale checking. Disabling\n                auto-scaling can lead to significant performance gains as it allows\n                \"bundling\" scaling ops. However, it is advanced feature and can lead\n                to unexpected results if used incorrectly. Defaults to False.\n\n        Raises:\n            TypeError: If the other value is of an incompatible type.\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            SecretRational: Result of the multiplication.\n        \"\"\"\n        if not isinstance(other, (Rational, SecretRational)):\n            return NotImplemented\n\n        if not ignore_scale and self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot multiply values with different scales.\")\n\n        return SecretRational(\n            self.value * other.value, self.log_scale + other.log_scale\n        )\n\n    def mul(self, other: _NadaRational, ignore_scale: bool = False) -> \"SecretRational\":\n        \"\"\"\n        Multiply two SecretRational numbers and rescale the result.\n\n        Args:\n            other (_NadaRational): The other SecretRational to multiply.\n            ignore_scale (bool, optional): Flag to disable scale checking. Disabling\n                auto-scaling can lead to significant performance gains as it allows\n                \"bundling\" scaling ops. However, it is advanced feature and can lead\n                to unexpected results if used incorrectly. Defaults to False.\n\n        Returns:\n            SecretRational: Result of the multiplication, rescaled.\n        \"\"\"\n        c = self.mul_no_rescale(other, ignore_scale=ignore_scale)\n        if c is NotImplemented:\n            # Note that, because this function would be executed under a NadaArray,\n            # the NotImplemented value will be handled by the caller (in principle NadaArray)\n            # The caller will then call the mul function of the NadaArray\n            # The broadcasting will execute element-wise multiplication,\n            # so rescale_down will be taken care by that function\n            return c\n        d = c.rescale_down()\n        return d\n\n    def __mul__(self, other: _NadaRational) -> \"SecretRational\":\n        \"\"\"\n        Multiply two secret rational numbers.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.mul(other)\n\n    def __imul__(self, other: _NadaRational) -> \"SecretRational\":\n        \"\"\"\n        Multiply two secret rational numbers inplace.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.mul(other)\n\n    def divide_no_rescale(\n        self, other: _NadaRational, ignore_scale: bool = False\n    ) -> \"SecretRational\":\n        \"\"\"\n        Divide two SecretRational numbers.\n\n        Args:\n            other (_NadaRational): The other SecretRational to divide by.\n            ignore_scale (bool, optional): Flag to disable scale checking. Disabling\n                auto-scaling can lead to significant performance gains as it allows\n                \"bundling\" scaling ops. However, it is advanced feature and can lead\n                to unexpected results if used incorrectly. Defaults to False.\n\n        Raises:\n            TypeError: If the other value is of an incompatible type.\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            SecretRational: Result of the division.\n        \"\"\"\n        if not isinstance(other, (Rational, SecretRational)):\n            return NotImplemented\n\n        if not ignore_scale and self.log_scale != other.log_scale + get_log_scale():\n            raise ValueError(\n                f\"Cannot divide values where scale is: {self.log_scale} / {other.log_scale}.\"\n                f\"Required scale: {self.log_scale}  / {other.log_scale + get_log_scale()}\"\n            )\n\n        return SecretRational(\n            self.value / other.value, self.log_scale - other.log_scale\n        )\n\n    def divide(\n        self, other: _NadaRational, ignore_scale: bool = False\n    ) -> \"SecretRational\":\n        \"\"\"\n        Divide two SecretRational numbers and rescale the result.\n\n        Args:\n            other (_NadaRational): The other SecretRational to divide by.\n            ignore_scale (bool, optional): Flag to disable scale checking. Disabling\n                auto-scaling can lead to significant performance gains as it allows\n                \"bundling\" scaling ops. However, it is advanced feature and can lead\n                to unexpected results if used incorrectly. Defaults to False.\n\n        Returns:\n            SecretRational: Result of the division, rescaled.\n        \"\"\"\n        # Note: If the other value is a NadaArray, the divide-no-rescale function will\n        # return NotImplemented\n        # This will cause that the divide function will return NotImplemented as well\n        # The NotImplemented value will be handled by the caller (in principle NadaArray)\n        # The caller will then call the divide function of the NadaArray\n        # The rescale up, because there is no follow up, will not be taken into consideration.\n        a = self.rescale_up()\n        c = a.divide_no_rescale(other, ignore_scale=ignore_scale)\n        return c\n\n    def __truediv__(self, other: _NadaRational) -> \"SecretRational\":\n        \"\"\"\n        Divide two secret rational numbers.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.divide(other)\n\n    def __itruediv__(self, other: _NadaRational) -> \"SecretRational\":\n        \"\"\"\n        Divide two secret rational numbers inplace.\n\n        Args:\n            other (_NadaRational): Other rational number to add.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the addition.\n        \"\"\"\n        return self.divide(other)\n\n    def __pow__(self, other: int) -> Union[\"Rational\", \"SecretRational\"]:\n        \"\"\"\n        Raise a SecretRational to an integer power using binary exponentiation.\n\n        Args:\n            other (int): The exponent.\n\n        Raises:\n            TypeError: If the exponent is not an integer.\n\n        Returns:\n            Union[Rational, SecretRational]: Result of the power operation.\n        \"\"\"\n        if not isinstance(other, int):\n            raise TypeError(\n                f\"Cannot raise SecretRational to a power of type `{type(other)}`\"\n            )\n\n        result = Rational(Integer(1), self.log_scale, is_scaled=False)\n\n        if other == 0:\n            return result  # Any number to the power of 0 is 1\n\n        base = self\n\n        exponent = abs(other)\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = result * base  # type: ignore\n            base *= base  # type: ignore\n            exponent //= 2\n\n        if other < 0:\n            return rational(1) / SecretRational(  # type: ignore\n                result.value, result.log_scale, is_scaled=True\n            )\n\n        return result\n\n    def __neg__(self) -> \"SecretRational\":\n        \"\"\"\n        Negate the SecretRational value.\n\n        Returns:\n            SecretRational: Negated SecretRational value.\n        \"\"\"\n        return SecretRational(self.value * Integer(-1), self.log_scale)\n\n    def __lshift__(self, other: UnsignedInteger) -> \"SecretRational\":\n        \"\"\"\n        Left shift the SecretRational value.\n\n        Args:\n            other (UnsignedInteger): The value to left shift by.\n\n        Returns:\n            SecretRational: Left shifted SecretRational value.\n        \"\"\"\n        return SecretRational(self.value << other, self.log_scale)\n\n    def __rshift__(self, other: UnsignedInteger) -> \"SecretRational\":\n        \"\"\"\n        Right shift the SecretRational value.\n\n        Args:\n            other (UnsignedInteger): The value to right shift by.\n\n        Returns:\n            SecretRational: Right shifted SecretRational value.\n        \"\"\"\n        return SecretRational(self.value >> other, self.log_scale)\n\n    def __lt__(self, other: _NadaRational) -> SecretBoolean:\n        \"\"\"\n        Check if this SecretRational is less than another.\n\n        Args:\n            other (_NadaRational): The other SecretRational to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            SecretBoolean: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        return SecretBoolean(self.value < other.value)\n\n    def __gt__(self, other: _NadaRational) -> SecretBoolean:\n        \"\"\"\n        Check if this SecretRational is greater than another.\n\n        Args:\n            other (_NadaRational): The other SecretRational to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            SecretBoolean: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        return SecretBoolean(self.value > other.value)\n\n    def __le__(self, other: _NadaRational) -> SecretBoolean:\n        \"\"\"\n        Check if this SecretRational is less than or equal to another.\n\n        Args:\n            other (_NadaRational): The other SecretRational to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            SecretBoolean: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        return SecretBoolean(self.value <= other.value)\n\n    def __ge__(self, other: _NadaRational) -> SecretBoolean:\n        \"\"\"\n        Check if this SecretRational is greater than or equal to another.\n\n        Args:\n            other (_NadaRational): The other SecretRational to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            SecretBoolean: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        return SecretBoolean(self.value >= other.value)\n\n    def __eq__(self, other: _NadaRational) -> SecretBoolean:  # type: ignore\n        \"\"\"\n        Check if this SecretRational is equal to another.\n\n        Args:\n            other (_NadaRational): The other SecretRational to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            SecretBoolean: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        return SecretBoolean(self.value == other.value)\n\n    def __ne__(self, other: _NadaRational) -> SecretBoolean:  # type: ignore\n        \"\"\"\n        Check if this SecretRational is not equal to another.\n\n        Args:\n            other (_NadaRational): The other SecretRational to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            SecretBoolean: Result of the comparison.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        return SecretBoolean(self.value != other.value)\n\n    def public_equals(self, other: _NadaRational) -> PublicBoolean:\n        \"\"\"\n        Check if this SecretRational is equal to another and reveal the result.\n\n        Args:\n            other (_NadaRational): The other SecretRational to compare against.\n\n        Raises:\n            ValueError: If the log scales of the two values are different.\n\n        Returns:\n            PublicBoolean: Result of the comparison, revealed.\n        \"\"\"\n        if self.log_scale != other.log_scale:\n            raise ValueError(\"Cannot compare values with different scales.\")\n        return self.value.public_equals(other.value)\n\n    def reveal(self) -> Rational:\n        \"\"\"\n        Reveal the SecretRational value.\n\n        Returns:\n            Rational: Revealed SecretRational value.\n        \"\"\"\n        return Rational(self.value.reveal(), self.log_scale)\n\n    def trunc_pr(self, arg_0: _NadaRational) -> \"SecretRational\":\n        \"\"\"\n        Truncate the SecretRational value.\n\n        Args:\n            arg_0 (_NadaRational): The value to truncate by.\n\n        Returns:\n            SecretRational: Truncated SecretRational value.\n        \"\"\"\n        return SecretRational(self.value.trunc_pr(arg_0), self.log_scale)\n\n    def rescale_up(self, log_scale: Optional[int] = None) -> \"SecretRational\":\n        \"\"\"\n        Rescale the SecretRational value upwards by a scaling factor.\n\n        Args:\n            log_scale (int, optional): The scaling factor. Defaults to RationalConfig.log_scale.\n\n        Returns:\n            SecretRational: Rescaled SecretRational value.\n        \"\"\"\n        if log_scale is None:\n            log_scale = get_log_scale()\n\n        return SecretRational(\n            self._value << UnsignedInteger(log_scale),\n            self.log_scale + log_scale,\n            is_scaled=True,\n        )\n\n    def rescale_down(self, log_scale: Optional[int] = None) -> \"SecretRational\":\n        \"\"\"\n        Rescale the SecretRational value downwards by a scaling factor.\n\n        Args:\n            log_scale (int, optional): The scaling factor. Defaults to RationalConfig.\n\n        Returns:\n            SecretRational: Rescaled SecretRational value.\n        \"\"\"\n        if log_scale is None:\n            log_scale = get_log_scale()\n\n        return SecretRational(\n            self._value >> UnsignedInteger(log_scale),\n            self.log_scale - log_scale,\n            is_scaled=True,\n        )\n\n    # Non-linear functions\n\n    def sign(self) -> \"SecretRational\":\n        \"\"\"Computes the sign value (0 is considered positive)\"\"\"\n\n        result = sign(self)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"sign input should be of type SecretRational.\")\n        return result\n\n    def abs(self) -> \"SecretRational\":\n        \"\"\"Computes the absolute value\"\"\"\n\n        result = fxp_abs(self)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"abs input should be of type SecretRational.\")\n        return result\n\n    def exp(self, iterations: int = 8) -> \"SecretRational\":\n        \"\"\"\n        Approximates the exponential function using a limit approximation.\n\n        The exponential function is approximated using the following limit:\n\n            exp(x) = lim_{n -> ∞} (1 + x / n) ^ n\n\n        The exponential function is computed by choosing n = 2 ** d, where d is\n        set to `iterations`. The calculation is performed by computing (1 + x / n)\n        once and then squaring it `d` times.\n\n        Approximation accuracy range (with 16 bit precision):\n        + ---------------------------------- +\n        |  Input range x |  Relative error   |\n        + ---------------------------------- +\n        |   [-2, 2]      |       <1%         |\n        |   [-7, 7]      |       <10%        |\n        |   [-8, 15]     |       <35%        |\n        + ---------------------------------- +\n\n        Args:\n            iterations (int, optional): The number of iterations for the limit approximation.\n                Defaults to 8.\n\n        Returns:\n            SecretRational: The approximated value of the exponential function.\n        \"\"\"\n\n        result = exp(self, iterations=iterations)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"exp input should be of type SecretRational.\")\n        return result\n\n    def polynomial(self, coefficients: list) -> \"SecretRational\":\n        \"\"\"\n        Computes a polynomial function on a value with given coefficients.\n\n        The coefficients can be provided as a list of values.\n        They should be ordered from the linear term (order 1) first, ending with the\n        highest order term.\n        **Note: The constant term is not included.**\n\n        Args:\n            coefficients (list): The coefficients of the polynomial, ordered by increasing degree.\n\n        Returns:\n            SecretRational: The result of the polynomial function applied to the input x.\n        \"\"\"\n\n        result = polynomial(self, coefficients=coefficients)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"polynomial input should be of type SecretRational.\")\n        return result\n\n    def log(\n        self,\n        input_in_01: bool = False,\n        iterations: int = 2,\n        exp_iterations: int = 8,\n        order: int = 8,\n    ) -> \"SecretRational\":\n        \"\"\"\n        Approximates the natural logarithm using 8th order modified Householder iterations.\n        This approximation is accurate within 2% relative error on the interval [0.0001, 250].\n\n        The iterations are computed as follows:\n\n            h = 1 - x * exp(-y_n)\n            y_{n+1} = y_n - sum(h^k / k for k in range(1, order + 1))\n\n        Approximation accuracy range (with 16 bit precision):\n        + ------------------------------------- +\n        |    Input range x  |  Relative error   |\n        + ------------------------------------- +\n        | [0.001, 200]      |     <1%           |\n        | [0.00003, 253]    |     <10%          |\n        | [0.0000001, 253]  |     <40%          |\n        | [253, +∞[         |     Unstable      |\n        + ------------------------------------- +\n\n        Args:\n            input_in_01 (bool, optional): Indicates if the input is within the domain [0, 1].\n                This setting optimizes the function for this domain, useful for computing\n                log-probabilities in entropy functions.\n\n                To shift the domain of convergence, a constant 'a' is used with the identity:\n\n                    ln(u) = ln(au) - ln(a)\n\n                Given the convergence domain for log() function is approximately [1e-4, 1e2],\n                we set a = 100.\n                Defaults to False.\n            iterations (int, optional): Number of Householder iterations for the approximation.\n                Defaults to 2.\n            exp_iterations (int, optional): Number of iterations for the limit approximation of\n                exp. Defaults to 8.\n            order (int, optional): Number of polynomial terms used (order of\n                Householder approximation). Defaults to 8.\n\n        Returns:\n            SecretRational: The approximate value of the natural logarithm.\n        \"\"\"\n\n        result = log(\n            self,\n            input_in_01=input_in_01,\n            iterations=iterations,\n            exp_iterations=exp_iterations,\n            order=order,\n        )\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"log input should be of type SecretRational.\")\n        return result\n\n    def reciprocal(  # pylint: disable=too-many-arguments\n        self,\n        all_pos: bool = False,\n        initial: Optional[\"Rational\"] = None,\n        input_in_01: bool = False,\n        iterations: int = 10,\n        log_iters: int = 1,\n        exp_iters: int = 8,\n        method: str = \"NR\",\n    ) -> \"SecretRational\":\n        r\"\"\"\n        Approximates the reciprocal of a number through two possible methods: Newton-Raphson\n        and log.\n\n        Methods:\n            'NR' : `Newton-Raphson`_ method computes the reciprocal using iterations\n                    of :math:`x_{i+1} = (2x_i - x * x_i^2)` and uses\n                    :math:`3*exp(1 - 2x) + 0.003` as an initial guess by default.\n\n                    Approximation accuracy range (with 16 bit precision):\n                    + ------------------------------------ +\n                    | Input range |x|  |  Relative error   |\n                    + ------------------------------------ +\n                    | [0.1, 64]        |       <0%         |\n                    | [0.0003, 253]    |       <15%        |\n                    | [0.00001, 253]   |       <90%        |\n                    | [253, +∞[        |     Unstable      |\n                    + ------------------------------------ +\n\n            'log' : Computes the reciprocal of the input from the observation that:\n                    :math:`x^{-1} = exp(-log(x))`\n\n                    Approximation accuracy range (with 16 bit precision):\n                    + ------------------------------------ +\n                    | Input range |x|  |  Relative error   |\n                    + ------------------------------------ +\n                    | [0.0003, 253]    |       <15%        |\n                    | [0.00001, 253]   |       <90%        |\n                    | [253, +∞[        |     Unstable      |\n                    + ------------------------------------ +\n\n        Args:\n            all_pos (bool, optional): determines whether all elements of the\n                input are known to be positive, which optimizes the step of\n                computing the sign of the input. Defaults to False.\n            initial (Rational, optional): sets the initial value for the\n                Newton-Raphson method. By default, this will be set to :math:\n                `3*exp(-(x-.5)) + 0.003` as this allows the method to converge over\n                a fairly large domain.\n            input_in_01 (bool, optional) : Allows a user to indicate that the input is\n                        in the range [0, 1], causing the function optimize for this range.\n                        This is useful for improving the accuracy of functions on\n                        probabilities (e.g. entropy functions).\n            iterations (int, optional):  determines the number of Newton-Raphson iterations to run\n                            for the `NR` method. Defaults to 10.\n            log_iters (int, optional): determines the number of Householder\n                iterations to run when computing logarithms for the `log` method. Defaults to 1.\n            exp_iters (int, optional): determines the number of exp\n                iterations to run when computing exp. Defaults to 8.\n            method (str, optional): method used to compute reciprocal. Defaults to \"NR\".\n\n        Returns:\n            SecretRational: The approximate value of the reciprocal\n\n        .. _Newton-Raphson:\n            https://en.wikipedia.org/wiki/Newton%27s_method\n        \"\"\"\n\n        result = reciprocal(\n            self,\n            all_pos=all_pos,\n            initial=initial,\n            input_in_01=input_in_01,\n            iterations=iterations,\n            log_iters=log_iters,\n            exp_iters=exp_iters,\n            method=method,\n        )\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"reciprocal input should be of type SecretRational.\")\n        return result\n\n    def inv_sqrt(\n        self,\n        initial: Optional[\"SecretRational\"] = None,\n        iterations: int = 5,\n        method: str = \"NR\",\n    ) -> \"SecretRational\":\n        r\"\"\"\n        Computes the inverse square root of the input using the Newton-Raphson method.\n\n        Approximation accuracy range (with 16 bit precision):\n        + ---------------------------------- +\n        | Input range x  |  Relative error   |\n        + ---------------------------------- +\n        | [0.1, 170]     |       <0%         |\n        | [0.001, 200]   |       <50%        |\n        | [200, +∞[      |     Unstable      |\n        + ---------------------------------- +\n\n        Args:\n            initial (Union[SecretRational, None], optional): sets the initial value for the\n                        Newton-Raphson iterations. By default, this will be set to allow the\n                        method to converge over a fairly large domain.\n            iterations (int, optional): determines the number of Newton-Raphson iterations to run.\n            method (str, optional): method used to compute inv_sqrt. Defaults to \"NR\".\n\n        Returns:\n            SecretRational: The approximate value of the inv_sqrt.\n\n        .. _Newton-Raphson:\n            https://en.wikipedia.org/wiki/Fast_inverse_square_root#Newton's_method\n        \"\"\"\n\n        result = inv_sqrt(self, initial=initial, iterations=iterations, method=method)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"inv_sqrt input should be of type SecretRational.\")\n        return result\n\n    def sqrt(\n        self,\n        initial: Optional[\"SecretRational\"] = None,\n        iterations: int = 5,\n        method: str = \"NR\",\n    ) -> \"SecretRational\":\n        r\"\"\"\n        Computes the square root of the input by computing its inverse square root using\n        the Newton-Raphson method and multiplying by the input.\n\n        Approximation accuracy range (with 16 bit precision):\n        + ---------------------------------- +\n        | Input range x  |  Relative error   |\n        + ---------------------------------- +\n        | [0.1, 170]     |       <0%         |\n        | [0.001, 200]   |       <50%        |\n        | [200, +∞[      |     Unstable      |\n        + ---------------------------------- +\n\n        Args:\n            initial (Union[SecretRational, None], optional): sets the initial value for the\n                inverse square root Newton-Raphson iterations. By default, this will be set\n                to allow convergence over a fairly large domain. Defaults to None.\n            iterations (int, optional):  determines the number of Newton-Raphson iterations to run.\n                Defaults to 5.\n            method (str, optional): method used to compute sqrt. Defaults to \"NR\".\n\n        Returns:\n            SecretRational: The approximate value of the sqrt.\n\n        .. _Newton-Raphson:\n            https://en.wikipedia.org/wiki/Fast_inverse_square_root#Newton's_method\n        \"\"\"\n\n        result = sqrt(self, initial=initial, iterations=iterations, method=method)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"sqrt input should be of type SecretRational.\")\n        return result\n\n    # Trigonometry\n\n    def cossin(self, iterations: int = 10) -> Tuple[\"SecretRational\", \"SecretRational\"]:\n        r\"\"\"Computes cosine and sine through e^(i * input) where i is the imaginary unit\n        through the formula:\n\n        .. math::\n            Re\\{e^{i * input}\\}, Im\\{e^{i * input}\\} = \\cos(input), \\sin(input)\n\n        Args:\n            iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n        Returns:\n            Tuple[SecretRational, SecretRational]:\n                A tuple where the first element is cos and the second element is the sin.\n        \"\"\"\n\n        result = cossin(self, iterations=iterations)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"cossin input should be of type SecretRational.\")\n        return result\n\n    def cos(self, iterations: int = 10) -> \"SecretRational\":\n        r\"\"\"Computes the cosine of the input using cos(x) = Re{exp(i * x)}.\n\n        Note: unstable outside [-30, 30]\n\n        Args:\n            iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n        Returns:\n            SecretRational: The approximate value of the cosine.\n        \"\"\"\n\n        result = cos(self, iterations=iterations)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"cos input should be of type SecretRational.\")\n        return result\n\n    def sin(self, iterations: int = 10) -> \"SecretRational\":\n        r\"\"\"Computes the sine of the input using sin(x) = Im{exp(i * x)}.\n\n        Note: unstable outside [-30, 30]\n\n        Args:\n            iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n        Returns:\n            SecretRational: The approximate value of the sine.\n        \"\"\"\n\n        result = sin(self, iterations=iterations)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"sin input should be of type SecretRational.\")\n        return result\n\n    def tan(self, iterations: int = 10) -> \"SecretRational\":\n        r\"\"\"Computes the tan of the input using tan(x) = sin(x) / cos(x).\n\n        Note: unstable outside [-30, 30]\n\n        Args:\n            iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n        Returns:\n            SecretRational: The approximate value of the tan.\n        \"\"\"\n\n        result = tan(self, iterations=iterations)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"tan input should be of type SecretRational.\")\n        return result\n\n    # Activation functions\n\n    def tanh(\n        self, chebyshev_terms: int = 32, method: str = \"reciprocal\"\n    ) -> \"SecretRational\":\n        r\"\"\"Computes the hyperbolic tangent function using the identity\n\n        .. math::\n            tanh(x) = 2\\sigma(2x) - 1\n\n        Methods:\n        If a valid method is given, this function will compute tanh using that method:\n\n            \"reciprocal\" - computes tanh using the identity\n\n                .. math::\n                tanh(x) = 2\\sigma(2x) - 1\n\n                Note: stable for x in [-250, 250]. Unstable otherwise.\n\n            \"chebyshev\" - computes tanh via Chebyshev approximation with truncation.\n\n                .. math::\n                    tanh(x) = \\sum_{j=1}^chebyshev_terms c_{2j - 1} P_{2j - 1} (x / maxval)\n\n                where c_i is the ith Chebyshev series coefficient and P_i is ith polynomial.\n\n                Note: stable for all input range as the approximation is truncated\n                        to +/-1 outside [-1, 1].\n\n            \"motzkin\" - computes tanh via approximation from the paper\n                \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n                on section 5.3 based on the Motzkin’s polynomial preprocessing technique.\n\n                Note: stable for all input range as the approximation is truncated\n                        to +/-1 outside [-1, 1].\n\n        Args:\n            chebyshev_terms (int, optional): highest degree of Chebyshev polynomials.\n                            Must be even and at least 6. Defaults to 32.\n            method (str, optional): method used to compute tanh function. Defaults to \"reciprocal\".\n\n        Returns:\n            SecretRational: The tanh evaluation.\n\n        Raises:\n            ValueError: Raised if method type is not supported.\n        \"\"\"\n\n        result = tanh(self, chebyshev_terms=chebyshev_terms, method=method)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"tanh input should be of type SecretRational.\")\n        return result\n\n    def sigmoid(\n        self, chebyshev_terms: int = 32, method: str = \"reciprocal\"\n    ) -> \"SecretRational\":\n        r\"\"\"Computes the sigmoid function using the following definition\n\n        .. math::\n            \\sigma(x) = (1 + e^{-x})^{-1}\n\n        Methods:\n        If a valid method is given, this function will compute sigmoid\n            using that method:\n\n            \"chebyshev\" - computes tanh via Chebyshev approximation with\n                truncation and uses the identity:\n\n                .. math::\n                    \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n                Note: stable for all input range as the approximation is truncated\n                        to 0/1 outside [-1, 1].\n\n            \"motzkin\" - computes tanh via approximation from the paper\n                \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n                on section 5.3 based on the Motzkin’s polynomial preprocessing technique.\n                It uses the identity:\n\n                .. math::\n                    \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n                Note: stable for all input range as the approximation is truncated\n                        to 0/1 outside [-1, 1].\n\n            \"reciprocal\" - computes sigmoid using :math:`1 + e^{-x}` and computing\n                the reciprocal\n\n                Note: stable for x in [-500, 500]. Unstable otherwise.\n\n        Args:\n            chebyshev_terms (int, optional): highest degree of Chebyshev polynomials.\n                            Must be even and at least 6. Defaults to 32.\n            method (str, optional): method used to compute sigmoid function.\n                Defaults to \"reciprocal\".\n\n        Returns:\n            SecretRational: The sigmoid evaluation.\n\n        Raises:\n            ValueError: Raised if method type is not supported.\n        \"\"\"\n\n        result = sigmoid(self, chebyshev_terms=chebyshev_terms, method=method)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"sigmoid input should be of type SecretRational.\")\n        return result\n\n    def gelu(\n        self, method: str = \"tanh\", tanh_method: str = \"reciprocal\"\n    ) -> \"SecretRational\":\n        r\"\"\"Computes the gelu function using the following definition\n\n        .. math::\n            gelu(x) = x/2 * (1 + tanh(\\sqrt{2/\\pi} * (x + 0.04471 * x^3)))\n\n        Methods:\n        If a valid method is given, this function will compute gelu\n            using that method:\n\n            \"tanh\" - computes gelu using the common approximation function\n\n                Note: stable for x in [-18, 18]. Unstable otherwise.\n\n            \"motzkin\" - computes gelu via approximation from the paper\n                \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n                on section 5.2 based on the Motzkin’s polynomial preprocessing technique.\n\n                Note: stable for all input range as the approximation is truncated\n                to relu function outside [-2.7, 2.7].\n\n        Args:\n            method (str, optional): method used to compute gelu function. Defaults to \"tanh\".\n            tanh_method (str, optional): method used for tanh function. Defaults to \"reciprocal\".\n\n        Returns:\n            SecretRational: The gelu evaluation.\n\n        Raises:\n            ValueError: Raised if method type is not supported.\n        \"\"\"\n\n        result = gelu(self, method=method, tanh_method=tanh_method)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"gelu input should be of type SecretRational.\")\n        return result\n\n    def silu(\n        self,\n        method_sigmoid: str = \"reciprocal\",\n    ) -> \"SecretRational\":\n        r\"\"\"Computes the gelu function using the following definition\n\n        .. math::\n            silu(x) = x * sigmoid(x)\n\n        Sigmoid methods:\n        If a valid method is given, this function will compute sigmoid\n            using that method:\n\n            \"chebyshev\" - computes tanh via Chebyshev approximation with\n                truncation and uses the identity:\n\n                .. math::\n                    \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n                Note: stable for all input range as the approximation is truncated\n                        to 0/1 outside [-1, 1].\n\n            \"motzkin\" - computes tanh via approximation from the paper\n                \"BOLT: Privacy-Preserving, Accurate and Efficient Inference for Transformers\"\n                on section 5.3 based on the Motzkin’s polynomial preprocessing technique.\n                It uses the identity:\n\n                .. math::\n                    \\sigma(x) = \\frac{1}{2}tanh(\\frac{x}{2}) + \\frac{1}{2}\n\n                Note: stable for all input range as the approximation is truncated\n                        to 0/1 outside [-1, 1].\n\n            \"reciprocal\" - computes sigmoid using :math:`1 + e^{-x}` and computing\n                the reciprocal\n\n                Note: stable for x in [-500, 500]. Unstable otherwise.\n\n        Args:\n            method_sigmoid (str, optional): method used to compute sigmoid function.\n            Defaults to \"reciprocal\".\n\n        Returns:\n            SecretRational: The sigmoid evaluation.\n\n        Raises:\n            ValueError: Raised if sigmoid method type is not supported.\n        \"\"\"\n\n        result = silu(self, method_sigmoid=method_sigmoid)\n        if not isinstance(result, SecretRational):\n            raise TypeError(\"silu input should be of type SecretRational.\")\n        return result\n\n\ndef secret_rational(\n    name: str, party: Party, log_scale: Optional[int] = None, is_scaled: bool = True\n) -> SecretRational:\n    \"\"\"\n    Creates a SecretRational from a variable in the Nillion network.\n\n    Args:\n        name (str): Name of variable in Nillion network.\n        party (Party): Name of party that provided variable.\n        log_scale (int, optional): Quantization scaling factor. Defaults to None.\n        is_scaled (bool, optional): Flag that indicates whether provided value has already been\n            scaled by log_scale factor. Defaults to True.\n\n    Returns:\n        SecretRational: Instantiated SecretRational object.\n    \"\"\"\n    value = SecretInteger(Input(name=name, party=party))\n    return SecretRational(value, log_scale, is_scaled)\n\n\ndef public_rational(\n    name: str, party: Party, log_scale: Optional[int] = None, is_scaled: bool = True\n) -> Rational:\n    \"\"\"\n    Creates a Rational from a variable in the Nillion network.\n\n    Args:\n        name (str): Name of variable in Nillion network.\n        party (Party): Name of party that provided variable.\n        log_scale (int, optional): Quantization scaling factor. Defaults to None.\n        is_scaled (bool, optional): Flag that indicates whether provided value has already been\n            scaled by log_scale factor. Defaults to True.\n\n    Returns:\n        Rational: Instantiated Rational object.\n    \"\"\"\n    value = PublicInteger(Input(name=name, party=party))\n    return Rational(value, log_scale, is_scaled)\n\n\ndef rational(\n    value: Union[int, float, np.floating],\n    log_scale: Optional[int] = None,\n    is_scaled: bool = False,\n) -> Rational:\n    \"\"\"\n    Creates a Rational from a number variable.\n\n    Args:\n        value (Union[int, float, np.floating]): Provided input value.\n        log_scale (int, optional): Quantization scaling factor. Defaults to default log_scale.\n        is_scaled (bool, optional): Flag that indicates whether provided value has already been\n            scaled by log_scale factor. Defaults to True.\n\n    Returns:\n        Rational: Instantiated Rational object.\n    \"\"\"\n    if value == 0:  # no use in rescaling 0\n        return Rational(Integer(0), is_scaled=True)\n\n    if log_scale is None:\n        log_scale = get_log_scale()\n\n    if isinstance(value, np.floating):\n        value = value.item()\n    if isinstance(value, int):\n        return Rational(Integer(value), log_scale=log_scale, is_scaled=is_scaled)\n    if isinstance(value, float):\n        assert (\n            is_scaled is False\n        ), \"Got a value of type `float` with `is_scaled` set to True. This should never occur\"\n        quantized = round(value * (1 << log_scale))\n        return Rational(Integer(quantized), is_scaled=True)\n    raise TypeError(f\"Cannot instantiate Rational from type `{type(value)}`.\")\n\n\nclass _MetaRationalConfig(type):\n    \"\"\"Rational config metaclass that defines classproperties\"\"\"\n\n    _log_scale: int\n    _default_log_scale: int\n\n    @property\n    def default_log_scale(cls) -> int:\n        \"\"\"\n        Getter method.\n\n        Returns:\n            int: Default log scale.\n        \"\"\"\n        return cls._default_log_scale\n\n    @property\n    def log_scale(cls) -> int:\n        \"\"\"\n        Getter method.\n\n        Returns:\n            int: Log scale.\n        \"\"\"\n        return cls._log_scale\n\n    @log_scale.setter\n    def log_scale(cls, new_log_scale: int) -> None:\n        \"\"\"\n        Setter method.\n\n        Args:\n            new_log_scale (int): New log scale value to reset old value with.\n        \"\"\"\n        if new_log_scale <= 4:\n            warnings.warn(\n                f\"Provided log scale `{str(new_log_scale)}` is very low.\"\n                \" Expected a value higher than 4.\"\n                \" Using a low quantization scale can lead to poor quantization of rational values\"\n                \" and thus poor performance & unexpected results.\"\n            )\n        if new_log_scale >= 64:\n            warnings.warn(\n                f\"Provided log scale `{str(new_log_scale)}` is very high.\"\n                \" Expected a value lower than 64.\"\n                \" Using a high quantization scale can lead to overflows & unexpected results.\"\n            )\n\n        cls._log_scale = new_log_scale\n\n\n# pylint:disable=too-few-public-methods\nclass _RationalConfig(metaclass=_MetaRationalConfig):\n    \"\"\"Rational config data class\"\"\"\n\n    _default_log_scale: int = 16\n    _log_scale: int = _default_log_scale\n\n\ndef set_log_scale(new_log_scale: int) -> None:\n    \"\"\"\n    Sets the default Rational log scaling factor to a new value.\n    Note that this value is the LOG scale and will be used as a base-2 exponent\n    during quantization.\n\n    Args:\n        new_log_scale (int): New log scaling factor.\n    \"\"\"\n    if not isinstance(new_log_scale, int):\n        raise TypeError(\n            f\"Cannot set log scale to type `{type(new_log_scale)}`. Expected `int`.\"\n        )\n    _RationalConfig.log_scale = new_log_scale\n\n\ndef get_log_scale() -> int:\n    \"\"\"\n    Gets the Rational log scaling factor\n    Note that this value is the LOG scale and is used as a base-2 exponent during quantization.\n\n    Returns:\n        int: Current log scale in use.\n    \"\"\"\n    return _RationalConfig.log_scale\n\n\ndef reset_log_scale() -> None:\n    \"\"\"Resets the Rational log scaling factor to the original default value\"\"\"\n    _RationalConfig.log_scale = _RationalConfig.default_log_scale\n\n\n# Fixed-point math operations\n\n# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n#\n# Part of the code is from the CrypTen Facebook Project:\n# https://github.com/facebookresearch/CrypTen/blob/main/crypten/common/functions/logic.py\n# https://github.com/facebookresearch/CrypTen/blob/main/crypten/common/functions/approximations.py\n#\n# Modifications:\n# July, 2024\n#   - Nada datatypes.\n#   - Relative accuracy documentation.\n#   - Some performance improvements.\n#   - Fixed Tanh Chebyshev method by changing '_hardtanh' implementation.\n#   - Tan.\n#   - Motzkin's prolynomial preprocessing approach.\n#   - GeLU and SiLU functions.\n\n\ndef sign(x: _NadaRational) -> _NadaRational:\n    \"\"\"Computes the sign value (0 is considered positive)\"\"\"\n\n    ltz_cond = x < rational(0)\n    ltz = ltz_cond.if_else(rational(1), rational(0))\n\n    return rational(1) - ltz - ltz\n\n\ndef fxp_abs(x: _NadaRational) -> _NadaRational:\n    \"\"\"Computes the absolute value of a rational\"\"\"\n    return x * sign(x)\n\n\ndef exp(x: _NadaRational, iterations: int = 8) -> _NadaRational:\n    \"\"\"\n    Approximates the exponential function using a limit approximation.\n    \"\"\"\n\n    iters_na = UnsignedInteger(iterations)\n\n    result = rational(1) + (x >> iters_na)\n    for _ in range(iterations):\n        result = result**2\n    return result\n\n\ndef polynomial(x: _NadaRational, coefficients: List[Rational]) -> _NadaRational:\n    \"\"\"\n    Computes a polynomial function on a value with given coefficients.\n\n    The coefficients can be provided as a list of values.\n    They should be ordered from the linear term (order 1) first, ending with the highest order term.\n    **Note: The constant term is not included.**\n    \"\"\"\n    result = coefficients[0] * x\n\n    for power, coeff in enumerate(coefficients[1:], start=2):\n        result += coeff * (x**power)\n\n    return result\n\n\ndef log(\n    x: _NadaRational,\n    input_in_01: bool = False,\n    iterations: int = 2,\n    exp_iterations: int = 8,\n    order: int = 8,\n) -> _NadaRational:\n    \"\"\"\n    Approximates the natural logarithm using 8th order modified Householder iterations.\n    \"\"\"\n\n    if input_in_01:\n        return log(\n            x * rational(100),\n            iterations=iterations,\n            exp_iterations=exp_iterations,\n            order=order,\n        ) - rational(4.605170)\n\n    # Initialization to a decent estimate (found by qualitative inspection):\n    #                ln(x) = x/120 - 20exp(-2x - 1.0) + 3.0\n    term1 = x * rational(1 / 120.0)\n    term2 = exp(-x - x - rational(1), iterations=exp_iterations) * rational(20)\n    y = term1 - term2 + rational(3.0)\n\n    # 8th order Householder iterations\n    for _ in range(iterations):\n        h = rational(1) - x * exp(-y, iterations=exp_iterations)\n        y -= polynomial(h, [rational(1 / (i + 1)) for i in range(order)])\n    return y\n\n\ndef reciprocal(  # pylint: disable=too-many-arguments\n    x: _NadaRational,\n    all_pos: bool = False,\n    initial: Optional[Rational] = None,\n    input_in_01: bool = False,\n    iterations: int = 10,\n    log_iters: int = 1,\n    exp_iters: int = 8,\n    method: str = \"NR\",\n) -> _NadaRational:\n    \"\"\"\n    Approximates the reciprocal of a number through two possible methods: Newton-Raphson\n    and log.\n    \"\"\"\n    if input_in_01:\n        rec = reciprocal(\n            x * rational(64),\n            method=method,\n            all_pos=True,\n            initial=initial,\n            iterations=iterations,\n        ) * rational(64)\n        return rec\n\n    if not all_pos:\n        sgn = sign(x)\n        pos = sgn * x\n        return sgn * reciprocal(\n            pos, method=method, all_pos=True, initial=initial, iterations=iterations\n        )\n\n    if method == \"NR\":\n        if initial is None:\n            # Initialization to a decent estimate (found by qualitative inspection):\n            #                1/x = 3exp(1 - 2x) + 0.003\n            result = rational(3) * exp(\n                rational(1) - x - x, iterations=exp_iters\n            ) + rational(0.003)\n        else:\n            result = initial\n        for _ in range(iterations):\n            result = result + result - result * result * x\n        return result\n    if method == \"log\":\n        return exp(-log(x, iterations=log_iters), iterations=exp_iters)\n    raise ValueError(f\"Invalid method {method} given for reciprocal function\")\n\n\ndef inv_sqrt(\n    x: _NadaRational,\n    initial: Optional[Union[_NadaRational, None]] = None,\n    iterations: int = 5,\n    method: str = \"NR\",\n) -> _NadaRational:\n    \"\"\"\n    Computes the inverse square root of the input using the Newton-Raphson method.\n    \"\"\"\n\n    if method == \"NR\":\n        if initial is None:\n            # Initialization to a decent estimate (found by qualitative inspection):\n            #                 exp(- x/2 - 0.2) * 2.2 + 0.2 - x/1024\n            y = exp(-(x >> UnsignedInteger(1)) - rational(0.2)) * rational(\n                2.2\n            ) + rational(0.2)\n            y -= x >> UnsignedInteger(10)  # div by 1024\n        else:\n            y = initial\n\n        # Newton Raphson iterations for inverse square root\n        for _ in range(iterations):\n            y = (y * (rational(3) - x * y * y)) >> UnsignedInteger(1)\n        return y\n    raise ValueError(f\"Invalid method {method} given for inv_sqrt function\")\n\n\ndef sqrt(\n    x: _NadaRational,\n    initial: Union[_NadaRational, None] = None,\n    iterations: int = 5,\n    method: str = \"NR\",\n) -> _NadaRational:\n    \"\"\"\n    Computes the square root of the input by computing its inverse square root using\n    the Newton-Raphson method and multiplying by the input.\n    \"\"\"\n\n    if method == \"NR\":\n        return inv_sqrt(x, initial=initial, iterations=iterations, method=method) * x\n\n    raise ValueError(f\"Invalid method {method} given for sqrt function\")\n\n\n# Trigonometry\n\n\ndef _eix(x: _NadaRational, iterations: int = 10) -> Tuple[_NadaRational, _NadaRational]:\n    r\"\"\"Computes e^(i * x) where i is the imaginary unit through the formula:\n\n    .. math::\n        Re\\{e^{i * x}\\}, Im\\{e^{i * x}\\} = \\cos(x), \\sin(x)\n\n    Args:\n        x (Union[Rational, SecretRational]): the input value.\n        iterations (int, optional): determines the number of iterations to run. Defaults to 10.\n\n    Returns:\n        Tuple[Union[Rational, SecretRational], Union[Rational, SecretRational]]:\n            A tuple where the first element is cos and the second element is the sin.\n    \"\"\"\n\n    one = rational(1)\n    im = x >> UnsignedInteger(iterations)\n\n    # First iteration uses knowledge that `re` is public and = 1\n    re = one - im * im\n    im *= rational(2)\n\n    # Compute (a + bi)^2 -> (a^2 - b^2) + (2ab)i `iterations` times\n    for _ in range(iterations - 1):\n        a2 = re * re\n        b2 = im * im\n        im = im * re\n        im *= rational(2)\n        re = a2 - b2\n\n    return re, im\n\n\ndef cossin(\n    x: _NadaRational, iterations: int = 10\n) -> Tuple[_NadaRational, _NadaRational]:\n    r\"\"\"\n    Computes cosine and sine through e^(i * x) where i is the imaginary unit.\n    \"\"\"\n    return _eix(x, iterations=iterations)\n\n\ndef cos(x: _NadaRational, iterations: int = 10) -> _NadaRational:\n    r\"\"\"\n    Computes the cosine of x using cos(x) = Re{exp(i * x)}.\n    \"\"\"\n    return cossin(x, iterations=iterations)[0]\n\n\ndef sin(x: _NadaRational, iterations: int = 10) -> _NadaRational:\n    r\"\"\"\n    Computes the sine of x using sin(x) = Im{exp(i * x)}.\n    \"\"\"\n    return cossin(x, iterations=iterations)[1]\n\n\ndef tan(x: _NadaRational, iterations: int = 10) -> _NadaRational:\n    r\"\"\"\n    Computes the tan of x using tan(x) = sin(x) / cos(x).\n    \"\"\"\n    c, s = cossin(x, iterations=iterations)\n    return s * reciprocal(c)\n\n\n# Activation functions\n\n\n@functools.lru_cache(maxsize=10)\ndef chebyshev_series(func, width, terms):\n    \"\"\"\n    Computes Chebyshev coefficients.\n    \"\"\"\n    n_range = np.arange(start=0, stop=terms, dtype=float)\n    x = width * np.cos((n_range + 0.5) * np.pi / terms)\n    y = func(x)\n    cos_term = np.cos(np.outer(n_range, n_range + 0.5) * np.pi / terms)\n    coeffs = (2 / terms) * np.sum(y * cos_term, axis=1)\n    return coeffs\n\n\ndef tanh(\n    x: _NadaRational, chebyshev_terms: int = 32, method: str = \"reciprocal\"\n) -> _NadaRational:\n    \"\"\"\n    Computes the hyperbolic tangent function.\n    \"\"\"\n\n    if method == \"reciprocal\":\n        return sigmoid(x + x, method=method) * rational(2) - rational(1)\n    if method == \"chebyshev\":\n        coeffs = chebyshev_series(np.tanh, 1, chebyshev_terms)[1::2]\n        # transform np.array of float to na.array of rationals\n        coeffs = np.vectorize(rational)(coeffs)\n        out = _chebyshev_polynomials(x, chebyshev_terms).transpose() @ coeffs\n        # truncate outside [-maxval, maxval]\n        return _hardtanh(x, out)\n    if method == \"motzkin\":\n        # Using approximation from \"BOLT: Privacy-Preserving, Accurate and Efficient\n        # Inference for Transformers\"\n        # section 5.3 based on the Motzkin’s polynomial preprocessing technique.\n\n        # ltz is used for absolute value of x and to compute sign (used to generate result).\n        # We don't use 'abs' and 'sign' functions to avoid computing ltz twice.\n        # sign = 1 - 2 * ltz, where ltz = (x < rational(0)).if_else(rational(1), rational(0))\n        sgn = rational(1) - rational(2) * (x < rational(0)).if_else(\n            rational(1), rational(0)\n        )\n        # absolute value\n        abs_x = x * sgn\n\n        # Motzkin’s polynomial preprocessing\n        t0 = rational(-4.259314087994767)\n        t1 = rational(18.86353816972803)\n        t2 = rational(-36.42402897526823)\n        t3 = rational(-0.013232131886235352)\n        t4 = rational(-3.3289339650097993)\n        t5 = rational(-0.0024920889620412097)\n        tanh_p0 = (abs_x + t0) * abs_x + t1\n        tanh_p1 = (tanh_p0 + abs_x + t2) * tanh_p0 * t3 * abs_x + t4 * abs_x + t5\n\n        return (abs_x > rational(2.855)).if_else(sgn, sgn * tanh_p1)\n    raise ValueError(f\"Unrecognized method {method} for tanh\")\n\n\n### Auxiliary functions for tanh\n\n\ndef _chebyshev_polynomials(x: _NadaRational, terms: int) -> np.ndarray:\n    \"\"\"Evaluates odd degree Chebyshev polynomials at x.\n\n    Chebyshev Polynomials of the first kind are defined as:\n\n    .. math::\n        P_0(x) = 1, P_1(x) = x, P_n(x) = 2 P_{n - 1}(x) - P_{n-2}(x)\n\n    Args:\n        x (Union[\"Rational\", \"SecretRational\"]): input at which polynomials are evaluated\n        terms (int): highest degree of Chebyshev polynomials.\n                        Must be even and at least 6.\n    Returns:\n        NadaArray of polynomials evaluated at x of shape `(terms, *x)`.\n\n    Raises:\n        ValueError: Raised if 'terrms' is odd and < 6.\n    \"\"\"\n    if terms % 2 != 0 or terms < 6:\n        raise ValueError(\"Chebyshev terms must be even and >= 6\")\n\n    # Initiate base polynomials\n    # P_0\n    # polynomials = np.array([x])\n    # y = rational(4) * x * x - rational(2)\n    # z = y - rational(1)\n    # # P_1\n    # polynomials = np.append(polynomials, z * x)\n\n    # # Generate remaining Chebyshev polynomials using the recurrence relation\n    # for k in range(2, terms // 2):\n    #     next_polynomial = y * polynomials[k - 1] - polynomials[k - 2]\n    #     polynomials = np.append(polynomials, next_polynomial)\n\n    # return polynomials\n\n    polynomials = [x]\n    y = rational(4) * x * x - rational(2)\n    z = y - rational(1)\n    # P_1\n    polynomials.append(z * x)\n\n    # Generate remaining Chebyshev polynomials using the recurrence relation\n    for k in range(2, terms // 2):\n        next_polynomial = y * polynomials[k - 1] - polynomials[k - 2]\n        polynomials.append(next_polynomial)\n\n    return np.array(polynomials)\n\n\ndef _hardtanh(\n    x: _NadaRational,\n    output: _NadaRational,\n    abs_const: _NadaRational = rational(1),\n    abs_range: _NadaRational = rational(1),\n) -> _NadaRational:\n    r\"\"\"Applies the HardTanh function element-wise.\n\n    HardTanh is defined as:\n\n    .. math::\n        \\text{HardTanh}(x) = \\begin{cases}\n            1 & \\text{ if } x > 1 \\\\\n            -1 & \\text{ if } x < -1 \\\\\n            Tanh(x) & \\text{ otherwise } \\\\\n        \\end{cases}\n\n    The range of the linear region :math:`[-1, 1]` can be adjusted using\n    :attr:`abs_range`.\n\n    Args:\n        x (Union[Rational, SecretRational]): the input value of the Tanh.\n        output (Union[Rational, SecretRational]): the output value of the approximation of Tanh.\n        abs_const (Union[Rational, SecretRational]): constant value to which |Tanh(x)| converges.\n            Defaults to 1.\n        abs_range (Union[Rational, SecretRational]): absolute value of the range. Defaults to 1.\n\n    Returns:\n        Union[Rational, SecretRational]: HardTanh output.\n    \"\"\"\n    # absolute value\n    sgn = sign(x)\n    abs_x = x * sgn\n    # chekc if inside [-abs_range, abs_range] interval\n    ineight_cond = abs_x < abs_range\n    result = ineight_cond.if_else(output, abs_const * sgn)\n\n    return result\n\n\n### End of auxiliary functions for tanh\n\n\ndef sigmoid(\n    x: _NadaRational, chebyshev_terms: int = 32, method: str = \"reciprocal\"\n) -> _NadaRational:\n    \"\"\"\n    Computes the sigmoid function.\n    \"\"\"\n    if method == \"chebyshev\":\n        tanh_approx = tanh(\n            x >> UnsignedInteger(1), method=method, chebyshev_terms=chebyshev_terms\n        )\n        return (tanh_approx >> UnsignedInteger(1)) + rational(0.5)\n    if method == \"motzkin\":\n        tanh_approx = tanh(\n            x >> UnsignedInteger(1), method=method, chebyshev_terms=chebyshev_terms\n        )\n        return (tanh_approx >> UnsignedInteger(1)) + rational(0.5)\n    if method == \"reciprocal\":\n        # ltz is used for absolute value of x and to generate 'result'.\n        # We don't use 'abs' function to avoid computing ltz twice.\n        ltz_cond = x < rational(0)\n        ltz = ltz_cond.if_else(rational(1), rational(0))\n        # compute absolute value of x\n        sgn = rational(1) - rational(2) * ltz\n        pos_x = x * sgn\n\n        denominator = exp(-pos_x) + rational(1)\n        pos_output = reciprocal(\n            denominator, all_pos=True, initial=rational(0.75), iterations=3, exp_iters=9\n        )\n\n        # result is equivalent to (1 - ltz).if_else(pos_output, 1 - pos_output)\n        result = pos_output + ltz - rational(2) * pos_output * ltz\n        return result\n    raise ValueError(f\"Unrecognized method {method} for sigmoid\")\n\n\ndef gelu(\n    x: _NadaRational, method: str = \"tanh\", tanh_method: str = \"reciprocal\"\n) -> _NadaRational:\n    \"\"\"\n    Computes the gelu function.\n    \"\"\"\n\n    if method == \"tanh\":\n        # Using common approximation:\n        #       x/2 * (1 + tanh(0.797884560 * ( x + 0.04471 * x ** 3 ) ) )\n        # where 0.797884560 ~= sqrt(2/pi).\n        val = rational(0.797884560) * (x + rational(0.044715) * x**3)\n        return (x * (rational(1) + tanh(val, method=tanh_method))) >> UnsignedInteger(1)\n    if method == \"motzkin\":\n        # Using approximation from \"BOLT: Privacy-Preserving, Accurate and Efficient\n        # Inference for Transformers\"\n        # section 5.2 based on the Motzkin’s polynomial preprocessing technique.\n\n        # ltz is used for absolute value of x and to compute relu.\n        # We don't use 'abs' and '_relu' functions to avoid computing ltz twice.\n        ltz = (x < rational(0)).if_else(rational(1), rational(0))\n        # absolute value\n        sgn = rational(1) - rational(2) * ltz\n        abs_x = x * sgn\n        # relu\n        relu = x * (rational(1) - ltz)\n\n        # Motzkin’s polynomial preprocessing\n        g0 = rational(0.14439048359960427)\n        g1 = rational(-0.7077117131613893)\n        g2 = rational(4.5702822654246535)\n        g3 = rational(-8.15444702051307)\n        g4 = rational(16.382265425072532)\n        gelu_p0 = (g0 * abs_x + g1) * abs_x + g2\n        gelu_p1 = (gelu_p0 + g0 * abs_x + g3) * gelu_p0 + g4 + (x >> UnsignedInteger(1))\n\n        return (abs_x > rational(2.7)).if_else(relu, gelu_p1)\n    raise ValueError(f\"Unrecognized method {method} for gelu\")\n\n\ndef silu(\n    x: _NadaRational,\n    method_sigmoid: str = \"reciprocal\",\n) -> _NadaRational:\n    \"\"\"\n    Computes the gelu function\n    \"\"\"\n    return x * sigmoid(x, method=method_sigmoid)\n"},"source_refs":[{"file":"list_scan_linear.py","lineno":9,"offset":328,"length":32},{"file":"list_scan_linear.py","lineno":8,"offset":259,"length":68},{"file":"list_scan_linear.py","lineno":18,"offset":523,"length":72},{"file":"list_scan_linear.py","lineno":22,"offset":656,"length":72},{"file":"list_scan_linear.py","lineno":5,"offset":140,"length":23},{"file":"list_scan_linear.py","lineno":28,"offset":864,"length":63},{"file":"list_scan_linear.py","lineno":25,"offset":778,"length":71},{"file":"list_scan_linear.py","lineno":29,"offset":928,"length":63},{"file":"funcs.py","lineno":107,"offset":2341,"length":65}]}